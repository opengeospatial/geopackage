[appendix]
[[abstract_test_suite]]
== Conformance / Abstract Test Suite (Normative)

=== Base

==== Core

===== SQLite Container

====== Data

*File Format*

[cols="1,5a"]
|========================================
|*Test Case ID* |++/base/core/container/data/file_format++
|*Test Purpose* |Verify that the Geopackage is an SQLite version_3 database
|*Test Method* |Pass if the first 16 bytes of the file contain “SQLite format 3” in ASCII.
|*Reference* |Clause 1.1.1.1.1 Req 1:
|*Test Type* |Basic
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |++/base/core/container/data/file_format/application_id++
|*Test Purpose* |Verify that the SQLite database header application id field indicates GeoPackage version 1.0
|*Test Method* |Pass if the application id field of the SQLite database header contains “GP10” in ASCII.
|*Reference* |Clause 1.1.1.1.1 Req 2:
|*Test Type* |Basic
|========================================

*File Extension Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |++/base/core/container/data/file_extension_name++
|*Test Purpose* |Verify that the geopackage extension is ".gpkg"
|*Test Method* |Pass if the geopackage file extension is ".gpkg"
|*Reference* |Clause 1.1.1.1.2 Req 3:
|*Test Type* |Basic
|========================================

*File Contents*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/container/data/file_contents+
|*Test Purpose* |Verify that the Geopackage only contains specified contents
|*Test Method* 
| . For each gpkg_* table_name
.. PRAGMA table_info(table_name)
.. Continue if returns an empty result set
.. Fail if column definitions returned by PRAGMA table_info do not match column definitions for the table in Annex C.
. Do test /opt/features/vector_features/data/feature_table_integer_primary_key
. Do test /opt/features/vector/features/data/feature_table_one_geometry_column
. Do test /opt/tiles/contents/data/tiles_row
. SELECT extension_name FROM gpkg_contents
. For each row from #4
.. Fail if the substring before the first “_” is not “gpkg”
. Pass if no fails
|*Reference* |Clause 1.1.1.1.3 Req 4:
|*Test Type* |Basic
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/container/data/table_data_types+
|*Test Purpose* |Verify that the data types of GeoPackage columns include only the types specified by <<table_column_data_types>>.
|*Test Method* |
. `SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’`
. Not testable if returns empty set
. For each row table name from step 1
.. PRAGMA table_info(table_name)
.. Fail if returns empty set
.. For each row type column value
... Fail if value is not one of the data type names specified by <<table_column_data_types>>
. Pass if no fails
|*Reference* |<<table_column_data_types>> Req 5:
|*Test Type* |Basic
|========================================

*Integrity Check*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/container/data/file_integrity+
|*Test Purpose* |Verify that the geopackage  passes the SQLite integrity check.
|*Test Method* |Pass if PRAGMA integrity_check returns “ok"
|*Reference* |Clause <<file_integrity>> Req 6:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/container/data/foreign_key_integrity+
|*Test Purpose* |Verify that the geopackage passes the SQLite foreign_key_check.
|*Test Method* |Pass if PRAGMA foreign_key_check() with no parameter value returns an empty result set
|*Reference* |Clause <<file_integrity>> Req 7:
|*Test Type* |Capability
|========================================

====== API

*Structured Query Language*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/container/api/sql+
|*Test Purpose* |Test that the GeoPackage SQLite Extension provides the SQLite SQL API interface.
|*Test Method* 
|. sqlite3_exec(‘SELECT * FROM sqlite_master;) 
. Fail if returns an SQL error.
. Pass otherwise 
|*Reference* |Clause 1.1.1.2.1 Req 8:
|*Test Type* |Capability
|========================================

*Every GPKG SQLite Configuration*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/container/api/every_gpkg_sqlite_config+
|*Test Purpose* |Verify that a GeoPackage SQLite Extension has the Every GeoPackage SQLite Configuration compile and run time options.
|*Test Method* 
|
. For each “SQLITE_OMIT_*” <option> listed at http://www.sqlite.org/compile.html#omitfeatures
.. +SELECT sqlite_compileoption_used('SQLITE_OMIT_<option>')+
.. Fail if returns 1
. PRAGMA foreign_keys
. Fail if returns 0
. Pass otherwise 
|*Reference* |Clause 1.1.1.2.2 Req 9:
|*Test Type* |Basic
|========================================

===== Spatial Reference Systems
====== Data
*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/gpkg_spatial_ref_sys/data/table_def+
|*Test Purpose* |Verify that the gpkg_spatial_ref_sys table exists and has the correct definition.
|*Test Method* |
. `SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'gpkg_spatial_ref_sys'`
. Fail if returns an empty result set
. Pass if column names and column definitions in the returned `CREATE TABLE statement` in the sql column value, including data type, nullability,  and primary key constraints match all of those in the contents of C.1 Table 18. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 1.1.2.1.1 Req 10:
|*Test Type* |Basic
|========================================

[[spatial_ref_sys_data_values_default]]
*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/gpkg_spatial_ref_sys/data_values_default+
|*Test Purpose* |Verify that the spatial_ref_sys table contains the required default contents.
|*Test Method* |
. `SELECT srid, auth_name, auth_srid, srtext FROM gpkg_spatial_ref_sys WHERE srid = -1 returns -1 “NONE” -1 “Undefined”, AND`
. `SELECT srid, auth_name, auth_srid, srtext FROM gpkg_spatial_ref_sys WHERE srid = 0 returns 0 “NONE” 0 “Undefined”, AND`
. `SELECT definition FROM gpkg_spatial_ref_sys WHERE organization IN (“epsg”,”EPSG”) AND organization_coordsys_id 4326` returns GEODCRS["WGS 84",
  DATUM["World Geodetic System 1984",
    ELLIPSOID["WGS 84",6378137, 298.257223563, LENGTHUNIT["metre", 1.0]]],
  PRIMEM["Greenwich", 0.0, ANGLEUNIT["degree",0.0174532925199433]],
  CS[ellipsoidal, 2],
  AXIS["latitude", north, ORDER[1]],
  AXIS["longitude", east, ORDER[2]],
  ANGLEUNIT["degree", 0.0174532925199433],
  ID["EPSG", 4326]]
. Pass if tests 1-3 are met
. Fail otherwise
|*Reference* |Clause 1.1.2.1.2 Requirement 11:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/spatial_ref_sys/data_values_required+
|*Test Purpose* |Verify that the spatial_ref_sys table contains rows to define all srs_id values used by features and tiles in a GeoPackage.
|*Test Method* |
. SELECT DISTINCT gc.srs_id AS gc_srid, srs.srs_name, srs.srs_id, srs.organization, srs.organization_coordsys_id, srs.definition FROM gpkg_contents AS gc LEFT OUTER JOIN gpkg_spatial_ref_sys AS srs ON srs.srs_id = gc.srs_id
. Pass if no returned srs values are NULL.
. Fail otherwise
|*Reference* |Clause Clause 1.1.2.1.2 Req 12:
|*Test Type* |Capability
|========================================

===== Contents 
====== Data
*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/contents/data/table_def+
|*Test Purpose* |Verify that the gpkg_contents table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_contents' 
. Fail if returns an empty result set. 
. Pass if the column names and column definitions in the returned CREATE TABLE statement, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of C.2 Table <<gpkg_contents_sql>>. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail Otherwise
|*Reference* |Clause 1.1.3.1.1 Req 13:
|*Test Type* |Basic
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/contents/data/data_values_table_name+
|*Test Purpose* |Verify that the table_name column values in the gpkg_contents table are valid.
|*Test Method* |
. SELECT DISTINCT gc.table_name AS gc_table, sm.tbl_name 
FROM gpkg_contents AS ge LEFT OUTER JOIN sqlite_master AS sm ON gc.table_name = sm.tbl_name
. Not testable if returns an empty result set.
. Fail if any gpkg_contents.table_name value is NULL 
. Pass otherwise.
|*Reference* |Clause 1.1.3.1.2 Req 14:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/contents/data/data_values_last_change+
|*Test Purpose* |Verify that the gpkg_contents table last_change column values are in ISO 8601 [29]format containing a complete date plus UTC hours, minutes, seconds and a decimal fraction of a second, with a ‘Z’ (‘zulu’) suffix indicating UTC.
|*Test Method* |
. SELECT last_change from gpkg_contents.
. Not testable if returns an empty result set.
. For each row from step 1
.. Fail if format of returned value does not match yyyy-mm-ddThh:mm:ss.hhhZ
.. Log pass otherwise
. Pass if logged pass and no fails.
|*Reference* |Clause 1.1.3.1.2 Req 15:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/base/core/contents/data/data_values_srs_id+
|*Test Purpose* |Verify that the gpkg_contents table srs_id column values reference gpkg_spatial_ref_sys srs_id column values.
|*Test Method* |
. PRAGMA foreign_key_check(‘gpkg_contents’)
. Fail if does not return an empty result set
|*Reference* |Clause 1.1.3.1.2 Req 16:
|*Test Type* |Capability
|========================================

=== Options

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/valid_geopackage+
|*Test Purpose* |Verify that a GeoPackage contains a features or tiles table and gpkg_contents table row describing it.
|*Test Method* |
. Execute test /opt/features/contents/data/features_row
. Pass if test passed
. Execute test /opt/tiles/contents/data/tiles_row
. Pass if test passed
. Fail otherwise
|*Reference* |Clause 2 Req 17:
|*Test Type* |Capability
|========================================

==== Features

===== Simple Features SQL Introduction

===== Contents

====== Data

*Contents Table Feature Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/contents/data/features_row+
|*Test Purpose* |Verify that the gpkg_contents table_name value table exists, and is apparently a feature table for every row with a data_type column value of “features”
|*Test Method* |
. Execute test /opt/features/vector_features/data/feature_table_integer_primary_key
|*Reference* |Clause 2.1.2.1.1 Req 18:
|*Test Type* |Capability
|========================================

===== Geometry Encoding

====== Data

*BLOB Format*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_encoding/data/blob+
|*Test Purpose* |Verify that geometries stored in feature table geometry columns are encoded in the StandardGeoPackageBinary format.
|*Test Method* |
. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’)
. Not testable if returns an empty result set
. For each row from step 1
.. SELECT cn FROM tn
.. Not testable if none found
.. For each cn value from step a
... Fail if the first two bytes of each gc are not “GP”
... Fail if gc.version_number is not 0
... Fail if gc.flags.GeopackageBinary type != 0
... Fail if ST_IsEmpty(cn value) = 1 and gc.flags.envelope != 0 and envelope values are not NaN
.  Pass if no fails
|*Reference* |Clause 2.1.3.1.1 Req 19:
|*Test Type* |Capability
|========================================

===== SQL Geometry Types

====== Data

*Core Types*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_encoding/data/core_types_existing_sparse_data+
|*Test Purpose* |Verify that existing basic simple feature geometries are stored in valid GeoPackageBinary format encodings.
|*Test Method* |
. SELECT table_name FROM gpkg_geometry_columns
. Not testable if returns an empty result set
. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’), 
. Fail if returns an empty result set
. For each row from step 3
.. SELECT cn FROM tn;
.. For each row from step a, if bytes 2-5 of cn.wkb as uint32 in endianness of gc.wkb byte 1of cn from #1 are a geometry type value from Annex E Table 42, then
... Log cn.header values, wkb endianness and geometry type 
... If cn.wkb is not correctly encoded per ISO 13249-3 clause 5.1.46 then log fail
... If cn.flags.E is 1 - 4 and some cn.wkbx is outside of cn.envelope.minx,maxx then log fail
... If cn.flags.E is 1 - 4 and some gc.wkby is outside of cn.envelope.miny,maxy then log fail
... If cn.flags.E is 2,4 and some gc.wkb.z is outside of cnenvelope.minz,maxz then log fail
... If cn.flags.E is 3,4 and some gc.wkb.m is outside of cn.envelope.minm,maxm then log fail
... If cn.flags.E is 5-7 then log fail 
... Otherwise log pass
. Pass if log contanins pass and no fails
|*Reference* |Clause 2.1.4.1.1 Req 20:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_encoding/data/core_types_all_types_test_data+
|*Test Purpose* |Verify that all basic simple feature geometry types and options are stored in valid GeoPackageBinary format encodings.
|*Test Method* |
. Open GeoPackage that has feature geometry values of geometry type inAnnex E, for an assortment of srs_ids, for an assortment of coordinate values, without and with z and / or m values, in both big and little endian encodings:
. /opt/features/geometry_encoding/data/core_types_existing_sparse_data
. Pass if log contains pass record for big and little endian GP headers containing big and little endian WKBs for 0-1 envelope contents indicator codes for every geometry type value from Annex E Table 41 without and with z and/or m values.
. Fail otherwise 
|*Reference* |Clause 2.1.4.1.1 Req 20:
|*Test Type* |Capability
|========================================

===== Geometry Columns

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/table_def+
|*Test Purpose* |Verify that the gpkg_geometry_columns table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_geometry_columns' 
. Fail if returns an empty result set. 
. Pass if the column names and column definitions in the returned Create TABLE statement in the sql column value, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of C.4Table 20. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 2.1.5.1.1 Req 21:
|*Test Type* |Basic
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_geometry_columns+
|*Test Purpose* |Verify that gpkg_geometry_columns contains one row record for each geometry column in each vector feature user data table.
|*Test Method* |
. SELECT table_name FROM gpkg_contents WHERE data_type = \'features'
. Not testable  if returns an empty result set
. SELECT table_name FROM gpkg_contents WHERE data_type = \'features' AND table_name NOT IN (SELECT table_name FROM gpkg_geometry_columns)
. Fail if result set is not empty
|*Reference* |Clause 2.1.5.1.2 Req 22:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_table_name+
|*Test Purpose* |Verify that the table_name column values in the gpkg_geometry_columns table are valid.
|*Test Method* | 
. PRAGMA foreign_key_check(‘geometry_columns’)
. Fail if returns any rows with a fourth column foreign key index value of 1 (gpkg_contents)
|*Reference* |Clause 2.1.5.1.2 Req 23:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_column_name+
|*Test Purpose* |Verify that the column_name column values in the gpkg_geometry_columns table are valid.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns
. Not testable  if returns an empty result set
. For each row from step 1
.. PRAGMA table_info(table_name) 
.. Fail if gpkg_geometry_columns.column_name value does not equal a name column value returned by PRAGMA table_info.
. Pass if no fails. 
|*Reference* |Clause 2.1.5.1.2 Req 24:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_geometry_type_name+
|*Test Purpose* |Verify that the geometry_type_name column values in the gpkg_geometry_columns table are valid.
|*Test Method* |
. SELECT DISTINCT geometry_type_name from gpkg_geometry_columns 
. Not testable  if returns an empty result set
. For each row from step 1
.. Fail if a returned geometry_type_name value is not in Table 42 or Table 43 in Annex E
. Pass if no fails.
|*Reference* |Clause 2.1.5.1.2 Req 25:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_srs_id+
|*Test Purpose* |Verify that the gpkg_geometry_columns table srs_id column values are valid.
|*Test Method* |
. PRAGMA foreign_key_check(‘gpkg_geometry_columns’)
. Fail if returns any rows with a fourth column foreign key index value of 0
|*Reference* |Clause 2.1.5.1.2 Req 26:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_z+
|*Test Purpose* |Verify that the gpkg_geometry_columns table z column values are valid.
|*Test Method* |
. SELECT z FROM gpkg_geometry_columns
. Not testable if returns an empty result set
. SELECT z FROM gpkg_geometry_columns WHERE z NOT IN (0,1,2)
. Fail if does not return an empty result set
. Pass otherwise.
|*Reference* |Clause 2.1.5.1.2 Req 27:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/geometry_columns/data/data_values_m+
|*Test Purpose* |Verify that the gpkg_geometry_columns table m column values are valid.
|*Test Method* |
. SELECT m FROM gpkg_geometry_columns
. Not testable if returns an empty result set
. SELECT m FROM gpkg_geometry_columns WHERE m NOT IN (0,1,2)
. Fail if does not return an empty result set
. Pass otherwise.
|*Reference* |Clause 2.1.5.1.2 Req 28:
|*Test Type* |Capability
|========================================

===== Vector Features User Data Tables

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/vector_features/data/feature_table_integer_primary_key+
|*Test Purpose* |Verify that every vector features user data table has an integer primary key.
|*Test Method* |
. SELECT table_name FROM gpkg_contents WERE data_type = ‘features’
. Not testable  if returns an empty result set
. For each row from step 1
.. PRAGMA table_info(table_name) 
.. Fail if returns an empty result set
.. Fail if result set does not contain one row where the pk column value is 1 and the not null column value is 1 and the type column value is “INTEGER”
. Pass if no fails.
|*Reference* |Clause 2.1.6.1.1 Req 29:
|*Test Type* |Basic
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/vector_features/data/feature_table_one_geometry_column+
|*Test Purpose* |Verify that every vector features user data table has one geometry column. 
|*Test Method* |
. SELECT table_name FROM gpkg_contents WERE data_type = ‘features’
. Not testable if returns an empty result set
. For each row table name from step 1
.. SELECT column_name from gpkg_geometry_columns where table_name = row table name 
.. Fail if returns more than one column name
. Pass if no fails
|*Reference* |Clause 2.1.6.1.1 Req 30:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/vector_features/data/feature_table_geometry_column_type+
|*Test Purpose* |Verify that the declared SQL type of a feature table geometry column is the uppercase geometry type name from Annex E specified by the geometry_type_name 
column for that column_name and table_name in the gpkg_geometry_columns table.
|*Test Method* |
. SELECT table_name, column_name, geometry_type_name table_name
FROM gpkg_geometry_columns WHERE table_name IN 
(SELECT table_name FROM gpkg_contents WHERE data_type = 'features')
. For each row selected in (1):
.. Fail if selected geometry_type_name value is not a value from the NAME column in Annex E Table 42 or Table 43.
.. SELECT sql FROM sqlite_master 
WHERE type = 'table' AND name = ‘{selected table_ name}’
.. Pass if declared type of column_name selected in (1) is the geometry_type_name selected in (1)
..	Fail otherwise
|*Reference* |Clause 2.1.6.1.1 Req 30b:
|*Test Type* |Capability
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/vector_features/data/data_values_geometry_type+
|*Test Purpose* |Verify that the geometry type of feature geometries are of the type or are assignable for the geometry type specified by the gpkg_geometry columns table geometry_type_name column value.
|*Test Method* |
. SELECT table_name AS tn, column_name AS cn, geometry_type_name AS gt_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’)
. Not testable if returns an empty result set
. For each row from step 1
.. SELECT DISTINCT ST_GeometryType(cn) FROM tn
.. For each row actual_type_name from step a
... SELECT GPKG_IsAssignable(geometry_type_name, actual_type_name) 
... Fail if any returned 0 
. Pass if no fails
|*Reference* |Clause 2.1.6.1.2 Req 31:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/features/vector_features/data/data_value_geometry_srs_id+
|*Test Purpose* |Verify the the srs_id of feature geometries are the srs_id specified for the gpkg_geometry_columns table srs_id column value.
|*Test Method* |
. SELECT table_name AS tn, column_name AS cn, srs_id AS gc_srs_id FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents where data_type = ‘features’)
. Not testable if returns an empty result set
. For each row from step 1
.. SELECT DISTINCT st_srid(cn) FROM tn
.. For each row from step a
... Fail if returnvalue not equal to gc_srs_id
. Pass if no fails
|*Reference* |Clause 2.1.6.1.2 Req 32:
|*Test Type* |Capability
|========================================

==== Tiles

===== Contents

====== Data

*Contents Table – Tiles Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/contents/data/tiles_row+
|*Test Purpose* |Verify that the gpkg_contents table_name value table exists and is apparently a tiles table for every row with a data_type column value of “tiles”.
|*Test Method* |
. SELECT table_name FROM gpkg_contents WHERE data_type = “tiles”
. Not testable  if returns empty result set
. For each row from step 1
.. PRAGMA table_info(table_name) 
.. Fail if returns an empty result set 
.. Fail if result set does not contain one row where the pk column value is 1 and the not null column value is 1 and the type column value is “INTEGER”and the name column value is “id” 
.. Fail if result set does not contain four other rows where the name column values are “zoom_level”,”tile_column”,”tile_row”, and “tile_data”.
. Pass if no fails.
|*Reference* |Clause 2.2.2.1.1 Req 33:
|*Test Type* |Capability
|========================================

===== Zoom Levels

====== Data

*Zoom Times Two*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/zoom_levels/data/zoom_times_two+
|*Test Purpose* |Verify that by default zoom level pixel sizes for tile matrix user data tables vary by factors of 2 between adjacent zoom levels in the tile matrix metadata table.
|*Test Method* |
. SELECT CASE 
WHEN (SELECT tbl_name FROM sqlite_master WHERE tbl_name = 'gpkg_extensions') = 'gpkg_extensions' THEN 
(SELECT table_name FROM gpkg_contents WHERE data_type = 'tiles' AND table_name NOT IN
 (SELECT table_name from gpkg_extensions WHERE extension_name = 'gpkg_zoom_other'))
ELSE (SELECT table_name FROM gpkg_contents WHERE data_type = 'tiles')
END;
. Not testable  if returns empty result set
. For each row table_name from step 1
.. SELECT zoom_level, pixel_x_size, pixel_y_size FROM gpkg_tile_matrix WHERE table_name = selected table name ORDER BY zoom_level ASC
.. Not testable  if returns empty result set, or only one row
.. Not testable  if there are not two rows with adjacent zoom levels
.. Fail if any pair of rows for adjacent zoom levels have pixel_x_size or pixel_y_size values that differ by other than factors of two
. Pass if no fails
|*Reference* |Clause 2.2.3.1.1 Req 34:
|*Test Type* |Capability
|========================================

===== Tile Encoding PNG
====== Data
*MIME Type PNG*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/tiles_encoding/data/mime_type_png+
|*Test Purpose* |Verify that a tile matrix user data table that contains tile data that is not MIME type image/jpeg by default contains tile data in MIME type image/png.
|*Test Method* |
. SELECT CASE 
WHEN (SELECT tbl_name FROM sqlite_master WHERE tbl_name = \'gpkg_extensions') = \'gpkg_extensions' THEN 
(SELECT table_name FROM gpkg_contents WHERE data_type = \'tiles' AND table_name NOT IN
 (SELECT table_name from gpkg_extensions WHERE extension_name IN (\'gpkg_webp')))
ELSE (SELECT table_name FROM gpkg_contents WHERE data_type = \'tiles')
END;
. Not testable if returns empty result set
. For each row tbl_name from step 1
.. SELECT tile_data FROM tbl_name
.. For each row tile_data from step a
... Pass if tile data in MIME type image/png
. Fail if no passes
|*Reference* |Clause 2.2.4.1.1 Req 35:
|*Test Type* |Capability
|========================================

===== Tile Encoding JPEG

====== Data

*MIME Type JPEG*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/tiles_encoding/data/mime_type_jpeg+
|*Test Purpose* |Verify that a tile matrix user data table that contains tile data that is not MIME type image/png by default contains tile data in MIME type image/jpeg.
|*Test Method* |
. SELECT CASE 
WHEN (SELECT tbl_name FROM sqlite_master WHERE tbl_name = \'gpkg_extensions') = \'gpkg_extensions' THEN 
(SELECT table_name FROM gpkg_contents WHERE data_type = \'tiles' AND table_name NOT IN
 (SELECT table_name from gpkg_extensions WHERE extension_name IN (\'gpkg_webp')))
ELSE (SELECT table_name FROM gpkg_contents WHERE data_type = \'tiles')
END;
. Not testable if returns empty result set
. For each row tbl_name from step 1
.. SELECT tile_data FROM tbl_name
.. For each row tile_data from step a
... Pass if tile data in MIME type image/jpeg
. Fail if no passes
|*Reference* |Clause 2.2.5.1.1 Req 36:
|*Test Type* |Capability
|========================================

===== Tile Matrix Set

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix_set/data/table_def+
|*Test Purpose* |Verify that the gpkg_tile_matrix_set table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_tile_matrix_set' 
. Fail if returns an empty result set. 
. Pass if the column names and column definitions in the returned CREATE TABLE statement in the sql column value,, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of <<example_feature_table_sql>>. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant. 
. Fail otherwise.
|*Reference* |Clause 2.2.6.1.1 Req 37:
|*Test Type* |Capability
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix_set/data/data_values_table_name+
|*Test Purpose* |Verify that values of the gpkg_tile_matrix_set table_name column reference values in the gpkg_contents table_name column for rows with a data type of “tiles”.
|*Test Method* |
. SELECT table_name FROM gpkg_tile_matrix_set
. Not testable if returns an empty result set
. SELECT table_name FROM gpkg_tile_matrix_set tms WHERE table_name NOT IN (SELECT table_name FROM gpkg_contents gc WHERE tms.table_name = gc.table_name AND gc.data_type != ‘tiles’)
. Fail if result set contains any rows
. Pass otherwise
|*Reference* |Clause 2.2.6.1.2 Req 38:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix_set/data/data_values_row_record+
|*Test Purpose* |Verify that the gpkg_tile_matrix_set table contains a row record for each tile pyramid  user data table .
|*Test Method* |
. SELECT table_name AS <user_data_tiles_table> from gpkg_contents where data_type = ‘tiles’
. Not testable if returns an empty result set
. For each row from step 1
.. SELECT sql FROM sqlite_master WHERE type=’table’ AND tbl_name =  '<user_data_tiles_table>'
.. Fail if returns an empty result set
. Pass if no fails 
|*Reference* |Clause 2.2.6.1.2 Req 39:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix_set/data/data_values_srs_id+
|*Test Purpose* |Verify that the gpkg_tile_matrix_set table srs_id column values reference gpkg_spatial_ref_sys srs_id column values.
|*Test Method* |
. PRAGMA foreign_key_check(‘gpkg_geometry_columns’)
. Fail if returns any rows with a fourth column foreign key index value of 1 (gpkg_spatial_ref_sys)
|*Reference* |Clause 2.2.6.1.2 Req 40:
|*Test Type* |Capability
|========================================

===== Tile Matrix 
====== Data
*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/table_def+
|*Test Purpose* |Verify that the gpkg_tile_matrix table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_tile_matrix' 
. Fail if returns an empty result set. 
. Pass if the column names and column definitions in the returned CREATE TABLE statement in the sql column value, including data type, nullability, default values, primary, and foreign key constraints match all of those in the contents of Annex C Table 23. 
. Fail otherwise.
|*Reference* |Clause 2.2.7.1.1 Req 41:
|*Test Type* |Basic
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_table_name+
|*Test Purpose* |Verify that values of the gpkg_tile_matrix table_name column reference values in the gpkg_contents table_name column for rows with a data type of “tiles”.
|*Test Method* |
. SELECT table_name FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT table_name FROM gpkg_tile_matrix tmm WHERE table_name NOT IN (SELECT table_name FROM gpkg_contents gc WHERE tmm.table_name = gc.table_name AND gc.data_type != ‘tiles’)
. Fail if result set contains any rows
. Pass otherwise
|*Reference* |Clause 2.2.7.1.2 Req 42:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_zoom_level_rows+
|*Test Purpose* |Verify that the gpkg_tile_matrix table contains a row record for each zoom level that contains one or more tiles in each tile pyramid  user data table.
|*Test Method* |
. SELECT table_name AS <user_data_tiles_table> from gpkg_contents where data_type = ‘tiles’
. Not testable if returns an empty result set
. For each row from step 1
.. SELECT DISTINCT gtmm.zoom_level AS gtmm_zoom, udt.zoom_level AS udtt_zoom FROM gpkg_tile_matrix AS gtmm 
 LEFT OUTER JOIN <user_data_tiles_table> AS udtt ON udtt.zoom_level =  gtmm.zoom_level AND gtmm.t_table_name = '<user_data_tiles_table>'
.. Fail if any gtmm_zoom column value in the result set is NULL
. Pass if no fails 
|*Reference* |Clause 2.2.7.1.2 Req 43:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_zoom_level+
|*Test Purpose* |Verify that zoom level column values in the gpkg_tile_matrix table are not negative.
|*Test Method* |
. SELECT zoom_level FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(zoom_level) FROM gpkg_tile_matrix_metadata.
. Fail if less than 0. 
. Pass otherwise.
|*Reference* |Clause 2.2.7.1.2 Req 44:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_matrix_width+
|*Test Purpose* |Verify that the matrix_width values in the gpkg_tile_matrix table are valid.
|*Test Method* |
. SELECT matrix_width FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(matrix_width) FROM gpkg_tile_matrix. 
. Fail if less than 1.
. Pass otherwise.
|*Reference:* |Clause 2.2.7.1.2 Req 45:
|*Test Type:* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_matrix_height+
|*Test Purpose* |Verify that the matrix_height values in the gpkg_tile_matrix table are valid.
|*Test Method* |
. SELECT matrix_height FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(matrix_height) FROM gpkg_tile_matrix.
. Fail if less than 1.
. Pass otherwise.
|*Reference* |Clause 2.2.7.1.2 Req 46:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_tile_width+
|*Test Purpose* |Verify that the tile_width values in the gpkg_tile_matrix table are valid.
|*Test Method* |
. SELECT tile_width FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(tile_width) FROM gpkg_tile_matrix.
. Fail if less than 1.
. Pass otherwise.
|*Reference* |Clause 2.2.7.1.2 Req 47:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_tile_height+
|*Test Purpose* |Verify that the tile_height values in the gpkg_tile_matrix table are valid.
|*Test Method* |
. SELECT tile_height FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(tile_height) FROM gpkg_tile_matrix.
. Fail if less than 1.
. Pass otherwise.
|*Reference* |Clause 2.2.7.1.2 Req 48:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_pixel_x_size+
|*Test Purpose* |Verify that the pixel_x_size values in the gpkg_tile_matrix table are valid.
|*Test Method* |
. SELECT pixel_x_size FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(pixel_x_size) FROM gpkg_tile_matrix.
. Fail if less than 0.
. Pass otherwise.
|*Reference* |Clause 2.2.7.1.2 Req 49:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_pixel_y_size+
|*Test Purpose* |Verify that the pixel_y_size values in the gpkg_tile_matrix table are valid.
|*Test Method* |
. SELECT pixel_y_size FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. SELECT min(pixel_y_size) FROM gpkg_tile_matrix.
. Fail if less than 0.
. Pass otherwise.
|*Reference* |Clause 2.2.7.1.2 Req 50:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/gpkg_tile_matrix/data/data_values_pixel_size_sort+
|*Test Purpose* |Verify that the pixel_x_size and pixel_y_size column values for zoom level column values in a gpkg_tile_matrix table sorted in ascending order are sorted in descending order, showing that lower zoom levels are zoomed “out”.
|*Test Method* |
. SELECT table_name FROM gpkg_contents WHERE data_type = ‘tiles’
. Not testable if returns empty result set
. For each row table_name from step 1
.. SELECT zoom_level, pixel_x_size, pixel_y_size from gpkg_tile_matrix WHERE table_name = row table name ORDER BY zoom_level ASC
.. Not testable if returns empty result set
.. Fail if pixel_x_sizes are not sorted in descending order
.. Fail if pixel_y_sizes are not sorted in descending order
. Pass if testable and no fails
|*Reference* |Clause 2.2.7.1.2 Req 51:
|*Test Type* |Capability
|========================================

===== Tile Pyramid User Data

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/tile_pyramid/data/table_def+
|*Test Purpose* |Verify that multiple tile pyramids are stored in different tiles tables with unique names containing the required columns.
|*Test Method* |
. SELECT COUNT(table_name) FROM gpkg_contents WERE data_type = “tiles”
. Not testable if less than 1
. SELECT table_name FROM gpkg_contents WHERE data_type = “tiles”
. For each row from step 3
.. PRAGMA table_info(table_name)
.. Fail if returns an empty result set 
.. Fail if result set does not contain one row where the pk column value is 1 and the not null column value is 1 and the type column value is “INTEGER”and the name column value is “id” 
.. Fail if result set does not contain four other rows where the name column values are “zoom_level”,”tile_column”,”tile_row”, and “tile_data”.
. Pass if no fails
|*Reference* |Clause 2.2.8.1.1 Req 52:
|*Test Type* |Basic
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/tile_pyramid/data/data_values_zoom_levels+
|*Test Purpose* |Verify that the zoom level column values in each tile pyramid user data table are within the range of zoom levels defined by rows in the gpkg_tile_matrix table.
|*Test Method* |
. SELECT DISTINCT table_name AS <user_data_tiles_table> FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. For each row <user_data_tiles_table> from step 1
.. SELECT zoom_level FROM <user_data_tiles_table>
.. If result set not empty
... SELECT MIN(gtmm.zoom_level) AS min_gtmm_zoom, MAX(gtmm.zoom_level) AS max_gtmm_zoom FROM gpkg_tile_matrix WHERE table_name = <user_data_tiles_table>
... SELECT id FROM <user_data_tiles_table> WHERE zoom_level < min_gtmm_zoom
... Fail if result set not empty
... SELECT id FROM <user_data_tiles_table> WHERE zoom_level > max_gtmm_zoom
... Fail if result set not empty
... Log pass otherwise
. Pass if logged pas and no fails
|*Reference* |Clause 2.2.8.1.2 Req 53:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/tile_pyramid/data/data_values_tile_column+
|*Test Purpose* |Verify that the tile_column column values for each zoom level value in each tile pyramid user data table are within the range of columns defined by rows in the gpkg_tile_matrix table.
|*Test Method* |
. SELECT DISTINCT table_name AS <user_data_tiles_table> FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. For each row <user_data_tiles_table> from step 1
.. SELECT DISTINCT gtmm.zoom_level AS gtmm_zoom, gtmm.matrix_width AS gtmm_width, udt.zoom_level AS udt_zoom, udt.tile_column AS udt_column FROM gpkg_tile_matrix AS gtmm LEFT OUTER JOIN <user_data_tiles_table> AS udt ON udt.zoom_level = gtmm.zoom_level AND gtmm.t_table_name = '<user_data_tiles_table>' AND (udt_column < 0 OR udt_column > (gtmm_width - 1))
.. Fail if any udt_column value in the result set is not NULL
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 2.2.8.1.2 Req 54:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/tiles/tile_pyramid_data/data_values_tile_row+
|*Test Purpose* |Verify that the tile_row column values for each zoom level value in each tile pyramid user data table are within the range of rows defined by rows in the gpkg_tile_matrix table.
|*Test Method* |
. SELECT DISTINCT table_name AS <user_data_tiles_table> FROM gpkg_tile_matrix
. Not testable if returns an empty result set
. For each row <user_data_tiles_table> from step 1
.. SELECT DISTINCT gtmm.zoom_level AS gtmm_zoom, gtmm.matrix_height AS gtmm_height, udt.zoom_level AS udt_zoom, udt.tile_row AS udt_row FROM gpkg_tile_matrix AS gtmm LEFT OUTER JOIN <user_data_tiles_table>  AS udt ON udt.zoom_level = gtmm.zoom_level AND gtmm.t_table_name = ‘<user_data_tiles_table> ' AND (udt_row < 0 OR udt_row > (gtmm_height - 1))
.. Fail if any udt_row value in the result set is not NULL
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 2.2.8.1.2 Req 55:
|*Test Type* |Capability
|========================================

==== Schema

===== Data Columns

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_columns/data/data_table_def+
|*Test Purpose* |Verify that the gpkg_data_columns table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_data_columns' 
. Fail if returns an empty result set
. Pass if column names and column definitions in the returned CREATE TABLE statement in the sql column value, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of Annex C8 Table 30. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 2.3.2.1.1 Req 56:
|*Test Type* |Basic
|========================================

*Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_columns/data/data_values_column_name+
|*Test Purpose* |Verify that for each gpkg_data_columns row, the column_name value is the name of a column in the table_name table.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_data_columns
. Not testable if returns an empty result set
. For each row from step 1
.. PRAGMA table_info(table_name) 
.. Fail if gpkg_data_columns.column_name value does not equal a name column value returned by PRAGMA table_info.
. Pass if no fails.
|*Reference* |Clause 2.3.2.1.2 Req 58:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_columns/data/data_values_constraint_name+
|*Test Purpose* |Verify that for each gpkg_data_columns row, the constraint_name value is either NULL or a constraint_name column value from the gpkg_data_column_constraints table.
|*Test Method* |
. SELECT constraint_name AS cn FROM gpkg_data_columns
. Not testable if returns an empty result set
. For each NOT NULL cn value from step 1
.. SELECT constraint_name FROM gpkg_data_column_constraints WHERE constraint_name = cn
.. Fail if returns an empty result set
. Pass if no fails
|*Reference* |Clause 2.3.2.1.2 Req 59:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_columns/data/data_values_constraint_type+
|*Test Purpose* |Verify that for each gpkg_data_columns row, if the constraint_name value is NOT NULL then the constraint_type column value contains a constraint_type column value from the gpkg_data_column_constraints table for a row with a matching constraint_name value.
|*Test Method* |
. SELECT constraint_name AS cn, constraint_type AS ct FROM gpkg_data_columns
. Not testable if returns an empty result set
. For each NOT NULL cn value from step 1
.. Fail if ct is NULL
.. If ct NOT NULL, SELECT constraint_type FROM gpkg_data_column_constraints WHERE constraint_name = cn AND constraint_type = ct
.. Fail if returns an empty result set
. Pass if no fails
|*Reference* |Clause 2.3.2.1.2 Req 59:
|*Test Type* |Capability
|========================================

===== Data Column Constraints

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_column_constraints/data/table_def+
|*Test Purpose* |Verify that the gpkg_data_column_constraints table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_data_column_constraints' 
. Fail if returns an empty result set
. Pass if column names and column definitions in the returned CREATE TABLE statement in the sql column value, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of Annex C Table 31. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 2.3.3.1.1 Req 60:
|*Test Type* |Basic
|========================================

*Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_column_constraints/data/data_values_constraint_type+
|*Test Purpose* |Verify that the gpkg_data_column_constraints constraint_type column values are one of "range", "enum", or "glob".
|*Test Method* |
. SELECT constraint_type AS ct FROM gpkg_data column_constraints
. Not testable if returns an empty result set
. For each ct value returned by step 1
.. Fail if ct NOT IN ("range", "enum", "glob").
. Pass if no fails.
|*Reference* |Clause 0 Req 61:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_column_constraints/data/data_values_constraint_names_unique+
|*Test Purpose* |Verify that the gpkg_data_column_constraints constraint_name column values for constraint_type values  of "range", or "glob" are unique.
|*Test Method* |
. For each SELECT DISTINCT constraint_name AS cn FROM gpkg_data_column_constraints  WHERE constraint_type IN (‘range’, ‘glob’)
.. SELECT count(*) FROM gpkg_data column_constraints WHERE constraint_name = cn
.. Fail if count > 1
. Pass if no fails.
|*Reference* |Clause 2.3.3.1.2 Req 62:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_column_constraints/data/data_values_value_for_range+
|*Test Purpose* |Verify that the gpkg_data_column_constraints value column values are NULL for rows with a constraint_type value of "range".
|*Test Method* |
. SELECT constraint_type AS ct, value AS v FROM gpkg_data column_constraints WHERE constraint_type = ‘range’
. Not testable if returns an empty result set
. For each v value returned by step 1
.. Fail if v IS NOT NULL
. Pass if no fails.
|*Reference* |Clause 2.3.3.1.2 Req 63:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_column_constraints/data/data_values_min_max_for_range+
|*Test Purpose* |Verify that the gpkg_data_column_constraints min column values are NOT NULL and less than the max column values for rows with a constraint_type value of "range".
|*Test Method* |
. SELECT min, max FROM gpkg_data column_constraints WHERE constraint_type = ‘range’
. Not testable if returns an empty result set
. For each set of min and max values returned by step 1
.. Fail if min IS NULL
.. Fail if max IS NULL
.. Fail if min >= max
. Pass if no fails.
|*Reference* |Clause 2.3.3.1.2 Req 64:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/schema/data_column_constraints/data/data_values_inclusive_for_range+
|*Test Purpose* |Verify that the gpkg_data_column_constraints minIsInclusive and maxIsInclusive  column values are NOT NULL and either 0 or 1 for rows with a constraint_type value of "range".
|*Test Method* |
. SELECT minIsInclusive, maxIsInclusive FROM gpkg_data column_constraints WHERE constraint_type = ‘range’
. Not testable if returns an empty result set
. For each set of values returned by step 1
.. Fail if minIsInclusive IS NULL
.. Fail if maxIsInclusive IS NULL
.. Fail if minIsInclusive is NOT IN (0,1)
.. Fail if maxIsInclusive is NOT IN (0,1)
. Pass if no fails.
|*Reference* |Clause 2.3.3.1.2 Req 65:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID:* |+/opt/schema/data_column_constraints/data/data_values_min_max_inclusive_for_enum_glob+
|*Test Purpose:* |Verify that the gpkg_data_column_constraints min, max, minIsInclusive and maxIsInclusive column values are NULL for rows with a constraint_type value of "enum" or “glob”.
|*Test Method:* |
. SELECT min, max, minIsInclusive, maxIsInclusive FROM gpkg_data column_constraints WHERE constraint_type  IN (‘enum’,’glob)
. Not testable if returns an empty result set
. For each set of values returned by step 1
.. Fail if min IS NOT NULL
.. Fail if max IS NOT NULL
.. Fail if minIsInclusive IS NOT NULL
.. Fail if maxIsInclusive IS NOT NULL
. Pass if no fails.
|*Reference* |Clause 2.3.3.1.2 Req 66:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID:* |+/opt/schema/data_column_constraints/data/data_values_value_for_enum_glob+
|*Test Purpose:* |Verify that the gpkg_data_column_constraints value column values are NOT NULL for rows with a constraint_type value of "enum" or “glob”.
|*Test Method:* |
. SELECT value FROM gpkg_data column_constraints WHERE constraint_type  IN (‘enum’,’glob)
. Not testable if returns an empty result set
. For each value returned by step 1
.. Fail if value IS NULL
. Pass if no fails.
|*Reference* |Clause 2.3.3.1.2 Req 67:
|*Test Type* |Capability
|========================================

==== Metadata

===== Metadata Table

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata/data/table_def+
|*Test Purpose* |Verify that the gpkg_metadata table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_metadata'
. Fail if returns an empty result set.
. Pass if the column names and column definitions in the returned Create TABLE statement in the sql column value, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of Table 33. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 2.4.2.1.1 Req 68:
|*Test Type* |Basic
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata/data/data_values_md_scope+
|*Test Purpose* |Verify that each of the md_scope column values in a gpkg_metadata table is one of the name column values from Table 15 in clause 2.4.2.1.2.
|*Test Method* |
. SELECT md_scope FROM gpkg_metadata
. Not testable if returns an empty result set
. For each row returned from step 1
.. Fail if md_scope value not one of the name column values from Table 15 in clause 2.4.2.1.2
. Pass if no fails
|*Reference* |Clause 2.4.2.1.2 Req 69:
|*Test Type:* |Capabilities
|========================================

===== Metadata Reference Table

====== Data

*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/table_def+
|*Test Purpose* |Verify that the gpkg_metadata_reference table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_metadata_reference'
. Fail if returns an empty result set.
. Pass if the column names and column definitions in the returned Create TABLE statement in the sql column value, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of Table 33.  Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 2.4.3.1.1 Req 70:
|*Test Type* |Basic
|========================================

*Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_reference_scope+
|*Test Purpose* |Verify that gpkg_metadata_reference table reference_scope column values are valid.
|*Test Method* |
. SELECT reference_scope FROM gpkg_metadata_reference
. Not testable if returns an empty result set
. SELECT reference_scope FROM gpkg_metadata_reference WHERE reference_scope NOT IN (‘geopackage’,’table’,’column’,’row’,’row/col’)
. Fail if does not return an empty result set
. Pass otherwise.
|*Reference* |Clause 2.4.3.1.2 Req 71:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_table_name+
|*Test Purpose* |Verify that gpkg_metadata_reference table_name column values are NULL for rows with reference_scope values of ‘geopackage’, and reference gpkg_contents table_name values for all other reference_scope values.
|*Test Method* |
. SELECT table_name FROM gpkg_metadata_reference
. Not testable if returns an empty result set
. SELECT table_name FROM gpkg_metadata_reference WHERE reference_scope = \'geopackage'
. Fail if result set contains any non-NULL values
. SELECT table_name FROM metadata_reference WHERE reference_scope != \'geopackage' AND table_name NOT IN (SELECT table_name FROM gpkg_contents)
. Fail if result set is not empty
. Pass otherwise.
|*Reference* |Clause 2.4.3.1.2 Req 72:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_column_name+
|*Test Purpose* |Verify that gpkg_metadata_reference column_name column values are NULL for rows with reference scope values of ‘geopackage’, ‘table’, or ‘row’, and contain the name of a column in table_name table for other reference scope values.
|*Test Method* |
. SELECT column_name FROM gpkg_metadata_reference
. Not testable if returns an empty result set
. SELECT column_name FROM gpkg_metadata_reference WHERE reference_scope IN ('geopackage', ‘table’, ‘row’)
. Fail if result set contains any non-NULL values
. SELECT <table_name>, <column_name> FROM metadata_reference WHERE reference_scope NOT IN ('geopackage', ‘table’, ‘row’)
. For each row from step 5
.. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'<table_name>'
.. Fail if returns an empty result set.
.. Fail if the one of the column names in the returned sql Create TABLE statement is not  <column_name>
.. Log pass otherwise
. Pass if logged pass and no fails.
|*Reference* |Clause 2.4.3.1.2 Req 73:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_row_id_value+
|*Test Purpose* |Verify that gpkg_metadata_reference row_id_value column values are NULL for rows with reference scope values of ‘geopackage’, ‘table’, or ‘row’, and contain the ROWID of a row in the table_name for other reference scope values.
|*Test Method* |
. SELECT row_id_value FROM gpkg_metadata_reference
. Not testable if returns an empty result set
. SELECT row_id_value FROM gpkg_metadata_reference WHERE reference_scope IN ('geopackage', ‘table’, ‘row’)
. Fail if result set contains any non-NULL values
. For each SELECT <table_name>, <row_id_value> FROM gpkg_metadata_reference WHERE reference_scope NOT IN ('geopackage', ‘table’, ‘row’)
. For each row from step 5
.. SELECT * FROM <table_name> WHERE ROWID = <row_id_value>
.. Fail if result set is empty
.. Log pass otherwise
. Pass if logged pass and no fails.
|*Reference* |Clause 2.4.3.1.2 Req 74:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_timestamp+
|*Test Purpose* |Verify that every gpkg_metadata_reference table row timestamp column value is in ISO 8601 UTC format.
|*Test Method* |
. SELECT timestamp from gpkg_metadata_reference.
.  Not testable if returns an empty result set
. For each row from step 1
.. Fail if format of returned value does not match yyyy-mm-ddThh:mm:ss.hhhZ
.. Log pass otherwise
. Pass if logged pass and no fails.
|*Reference* |Clause 2.4.3.1.2 Req 75:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_md_file_id+
|*Test Purpose* |Verify that every gpkg_metadata_reference table row md_file_id column value references a gpkg_metadata id column value.
|*Test Method* |
. PRAGMA foreign_key_check(‘geometry_columns’)
. Fail if returns any rows with a fourth column foreign key index value of 0
|*Reference* |Clause 2.4.3.1.2 Req 76:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/metadata/metadata_reference/data/data_values_md_parent_id+
|*Test Purpose* |Verify that every gpkg_metadata_reference table row md_parent_id column value that is not null is an id column value from the gpkg_metadata_table that is not equal to the md_file_id column value for that row.
|*Test Method* |
. SELECT md_file_id FROM gpkg_metadata_reference
. Not testable if returns an empty result set
. SELECT gmr.md_file_id, gmr.md_parent_id FROM gpkg_metadata_reference AS gmr WHERE gmr.md_file_id == gmr.md_parent_id
. Fail if result set is not empty
. SELECT gmr.md_file_id, gmr.md_parent_id, gm.id FROM gpkg_metadata_reference  AS gmr LEFT OUTER JOIN gpkg_metadata gm ON gmr.md_parent_id =gm.id
. Fail if any result set gm.id values are NULL
. Pass otherwise
|*Reference* |Clause 2.4.3.1.2 Req 77:
|*Test Type* |Capability
|========================================

==== Extension Mechanism
===== Extensions
====== Data
*Table Definition*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_mechanism/extensions/data/table_def+
|*Test Purpose* |Verify that a gpkg_extensions table exists and has the correct definition.
|*Test Method* |
. SELECT sql FROM sqlite_master WHERE type = \'table' AND tbl_name = \'gpkg_extensions'
. Fail if returns an empty result set.
. Pass if the column names and column definitions in the returned Create TABLE statement in the sql column value, including data type, nullability, default values and primary, foreign and unique key constraints match all of those in the contents of Table 36. Column order, check constraint and trigger definitions, and other column definitions in the returned sql are irrelevant.
. Fail otherwise.
|*Reference* |Clause 2.5.2.1.1 Req 78:
|*Test Type* |Basic
|========================================

*Table Data Values*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_metchanism/extensions/data/data_values_for_extensions+
|*Test Purpose* |Verify that every extension of a GeoPackage is registered in a row in the gpkg_extensions table
|*Test Method* |
. For each SELECT DISTINCT geometry_type_name FROM geometry_columns
.. Fail if geometry_type_name IN Annex E Table 43 and gpkg_extensions does not contain a row where extension_name = gpkg_geom_<geometry_type_name>
.. Fail if geometry_type_name NOT IN Annex E Table 42 or Table 43 and gpkg_extensions does not contain a row where the extension_name does not begin with “gpkg” and the extension_name ends with “_geom_<geometry_type_name>
. For each SELECT tbl_name FROM sqlite_master WHERE tbl_name LIKE ‘rtree_%’
.. Fail if gpkg_extensions does not contain a row where extension_name = “gpkg_rtree_index”
. For each SELECT tbl_name FROM sqlite_master WHERE name LIKE ‘fgti_%’
.. Fail if gpkg_extensions does not contain a row where extension_name = “gpkg_geometry_type_trigger”
. For each SELECT tbl_name FROM sqlite_master WHERE name LIKE ‘fgsi_%’
.. Fail if gpkg_extensions does not contain a row where extension_name = “gpkg_srs_id_trigger”
. Do test / reg_ext/tiles/zoom_levels/data/zoom_other_ext_row
. Do test /reg_ext/tiles/tile_encoding_webp/data/webp_ext_row
. Do test /reg_ext/tiles/tile_encoding_webp/data/tiff_ext_row
. Do test /reg_ext/tiles/tile_encoding_webp/data/nitf_ext_row
. Pass if no fails
|*Reference* |Clause 2.5.2.1.2 Req 79:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_metchanism/extensions/data/data_values_table_name+
|*Test Purpose* |Verify that the table_name column values in the gpkg_extensions table are valid.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_extensions
. Not testable if returns an empty result set
. For each row from step one
.. Fail if table_name value is NULL and column_name value is not NULL.
.. SELECT DISTINCT ge.table_name AS ge_table, sm.tbl_name FROM gpkg_extensions AS ge LEFT OUTER JOIN sqlite_master AS sm ON ge.table_name = sm.tbl_name
.. Log pass if every row ge.table_name = sm.tbl_name (MAY both be NULL).
. Pass if logged pass and no fails.
|*Reference* |Clause 2.5.2.1.2 Req 80:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_metchanism/extensions/data/data_values_column_name+
|*Test Purpose* |Verify that the column_name column values in the gpkg_extensions table are valid.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_extensions
. Not testable if returns an empty result set
. SELECT table_name, column_name FROM gpkg_extensions WHERE table_name IS NOT NULL AND column_name IS NOT NULL
. Pass if returns an empty result set
. For each row from step 3
.. PRAGMA table_info(table_name)
.. Fail if gpkg_extensions.column_name value does not equal a name column value returned by PRAGMA table_info.
.. Log pass otherwise
. Pass if logged pass and no fails.
|*Reference* |Clause 2.5.2.1.2 Req 81:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_mechanism/extensions/data/data_values_extension_name+
|*Test Purpose* |Verify that the extension_name column values in the gpkg_extensions table are valid.
|*Test Method* |
. SELECT extension_name FROM gpkg_extensions
. Not testable if returns an empty result set
. For each row returned from step 1
.. Log pass if extension_name is one of those listed in Annex J or Annex L through Annex P.
.. Separate extension_name into <author> and <extension> at the first “_”
.. Fail if <author> is “gpkg”
.. Fail if <author> contains characters other than [a-zA-Z0-9]
.. Fail if <extension> contains characters other than [a-zA-Z0-9_]
.. Log pass otherwise
. Pass if logged pass and no fails.
|*Reference* |Clause 2.5.2.1.2 Req 82:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_mechanism/extensions/data/data_values_definition+
|*Test Purpose* |Verify that the definition column value contains or references extension documentation
|*Test Method* |
. SELECT definition FROM gpkg_extensions
. Not testable if returns an empty result set
. For each row returned from step 1
.. Inspect if definition value is not like “Annex %”, or “http%” or mailto:% or “Extension Title%”
.. Fail if definition value does not contain or reference extension documentation
. Pass if no fails
|*Reference* |Clause 2.5.2.1.2 Req 83:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/opt/extension_mechanism/extensions/data/data_values_scope+
|*Test Purpose* |Verify that the scope column value is “read-write” or “write-only”
|*Test Method* |
. SELECT scope FROM gpkg_extensions
. Not testable if returns an empty result set
. For each row returned from step 1
.. Fail is value is not “read-write” or “write-only”
. Pass if no fails
|*Reference* |Clause 2.5.2.1.2 Req 84:
|*Test Type* |Capability
|========================================

=== Registered Extensions

==== Features

===== Geometry Types

====== Data

*GeoPackage Extension Types*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/geopackage_extension_types/existing_sparse_data+
|*Test Purpose* |Verify that existing extended non-linear geometry types are stored in valid StandardGeoPackageBinary format encodings.
|*Test Method* |
. SELECT table_name FROM gpkg_geometry_columns
. Not testable if returns an empty result set
. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’),
. Fail if returns an empty result set
. For each row from step 3
.. SELECT cn FROM tn;
.. For each row from step a, log fail if GeoPackageBinary “X” type flag is 1
.. For each row from step a, if bytes 2-5 of cn.wkb as uint32 in endianness of gc.wkb byte 1of cn from #1 are a geometry type value from Annex E Table 43, then
.. Log cn.header values, wkb endianness and geometry type
ii. If cn.wkb is not correctly encoded per ISO 13249-3 clause 5.1.46 then log fail
iii. If cn.flags.E is 1 - 4 and some cn.wkbx is outside of cn.envelope.minx,maxx then log fail
iv. If cn.flags.E is 1 - 4 and some gc.wkby is outside of cn.envelope.miny,maxy then log fail
.. If cn.flags.E is 2,4 and some gc.wkb.z is outside of cnenvelope.minz,maxz then log fail
vi. If cn.flags.E is 3,4 and some gc.wkb.m is outside of cn.envelope.minm,maxm then log fail
vii. If cn.flags.E is 5-7 then log fail
viii. Otherwise log pass
. Log pass if log contains pass and no fails
|*Reference* |Clause 3.1.1.1.1 Req 85:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/geopackage_extension_types/all_types_test_data+
|*Test Purpose* |Verify that all extended non-linear geometry types and options are stored in valid GeoPackageBinary format encodings.
|*Test Method* |
. Open GeoPackage that has feature geometry values of geometry type in Annex E, for an assortment of srs_ids, for an assortment of coordinate values, without and with z and / or m values, in both big and little endian encodings:
. /reg_ext/features/geometry_encoding/data/extension_types_existing_sparse_data
. Pass if log contains pass record for big and little endian GP headers containing big and little endian WKBs for 0-1 envelope contents indicator codes for every geometry type value from Annex E Table 43 without and with z and/or m values.
. Fail otherwise
|*Reference* |Clause 3.1.1.1.1 Req 85:
|*Test Type* |Capability
|========================================

*GeoPackage Geometry Types -- Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/geopackage_extension_types/extension_name+
|*Test Purpose* |Verify that an extension name in the form gpkg_geom_<gname> is defined for each <gname> extension geometry type from Annex E Table 43  used in a GeoPackage.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if result set is empty
. For each row result set table_name, column_name from step 3
.. SELECT result_set_column_name FROM result_set_table_name
.. For each geometry column value from step a
... If the first two bytes of each geometry column value are “GP”, then
.... /opt/extension_mechanism/extensions/data/table_def
.... Fail if failed
.... SELECT ST_GeometryType(geometry column value) AS <gtype>;
.... SELECT extension_name FROM gpkg_extensions WERE table_name = result_set_table_name AND column_name = result_set_column_name AND extension_name = \'gpkg_geom_' \|\| <gtype>
..... Fail if result set is empty
..... Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.1.1.2 Req 86:
|*Test Type* |Basic
|========================================

*GeoPackage Geometry Types -- Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/geopackage_extension_types/extension_row+
|*Test Purpose* |Verify that the gpkg_extensions table contains a row with an extension_name in the form gpkg_geom_<gname> for each table_name and column_name in the gpkg_geometry_columns table with a <gname> geometry_type_name.
|*Test Method* |
 /reg_ext/features/geometry_encoding/data/extension_name
|*Reference* |Clause 3.1.1.1.3 Req 87:
|*Test Type* |Capability
|========================================

===== User-Defined Geometry Types

====== Data
*Extensions Encoding*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/user_defined-geometry_types/existing_sparse_data+
|*Test Purpose* |Verify that existing extended geometry types not listed in Annex E are stored in valid ExtendedGeoPackageBinary format encodings.
|*Test Method* |
. SELECT table_name FROM gpkg_geometry_columns
. Not testable if returns an empty result set
. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns WHERE geometry_type_name NOT IN (all geometry types listed in Annex E) AND table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’),
. Fail if returns an empty result set
. For each row from step 3
.. SELECT cn FROM tn;
.. For each row from step a,
... log fail if GeoPackageBinary “X” type flag is 0
... Otherwise log pass
. Log pass if log contains pass and no fails
|*Reference* |Clause 3.1.1.1.1 Req 88:
|*Test Type* |Capability
|========================================

*Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/user_defined_geometry_types/extension_name+
|*Test Purpose* |Verify that an extension name in the form <author>_geom_<gname> is defined for each extended geometry type not listed in Annex E used in a GeoPackage.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == \'features'))
. Not testable if result set is empty
. For each row result set table_name, column_name from step 3
.. SELECT result_set_column_name FROM result_set_table_name
.. For each geometry column value from step a
... If the first two bytes of each geometry column value are “GP”, then
.... /opt/extension_mechanism/extensions/data/table_def
.... Fail if failed
.... SELECT ST_GeometryType(geometry column value) AS <gtype>;
.... SELECT extension_name FROM gpkg_extensions WERE table_name = result_set_table_name AND column_name = result_set_column_name AND extension_name NOT LIKE ‘gpkg_%’ and extension_name  LIKE \'%_geom_' \|\| <gtype>
..... Fail if result set is empty
..... Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.1.1.2 Req 89:
|*Test Type* |Basic
|========================================

*Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/user_defined_geometry_types/extension_row+
|*Test Purpose* |Verify that the gpkg_extensions table contains a row with an extension_name in the form <author>_geom_<gname> for each table_name and column_name in the gpkg_geometry_columns table with a <gname> geometry_type_name.
|*Test Method* |
 Do test /reg_ext/features/geometry_encoding/data/extension_encoding/extension_name
|*Reference* |Clause 3.1.1.1.3 Req 90:
|*Test Type* |Capability
|========================================

*Geometry Columns Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_encoding/data/user_defined_geometry_types/geometry_columns_row+
|*Test Purpose* |Verify that the gpkg_geometry_columns table contains a row with a geometry_type_name  in the form <author>_geom_<gname> for each feature table that contains user-defined geometry types specified in the gpkg_extensions table.
|*Test Method* |
. SELECT extension_name FROM gpkg_extensions WHERE extension_name LIKE ‘%_geom_%’ AND extension_name NOT LIKE ‘gpkg_geom_%’
. FOR EACH extension_name from #1
.. SELECT * FROM gpkg_geometry_columns WHERE geometry_type_name = extension_name
.. Fail if returns an empty result set
. Pass if no fails.

|*Reference* |Clause 3.1.2.1.4 Req 91:
|*Test Type* |Capability
|========================================

===== Spatial Indexes
====== Data
*Spatial Indexes Implementation*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/spatial_indexes/implementation+
|*Test Purpose* |Verify the correct implementation of spatial indexes on feature table geometry columns.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if result set is empty
. For each row table_name, column_name from step 1
.. SELECT sql FROM sqlite_master WHERE tbl_name = ‘rtree_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Not testable if result set is empty
.. Fail if returned sql != ‘CREATE VIRTUAL TABLE rtree_’ ’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name \|\| USING rtree(id, minx, maxx, miny, maxy)
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tname = ‘rtree_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name \|\| ‘_insert’
.. Fail if returned sql != result of populating insert triggers template in Annex L using result_set_table_name for <t> and result_set_column_name for <c>
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND name LIKE ‘rtree_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name \|\| ‘_update%’
.. Fail if returned sql != result of populating 4 update triggers templates in Annex L using result_set_table_name for <t> and result_set_column_name for <c>
.. SELECT sql FROM sqlite_master WHERE type=’trigger’ AND name = ‘rtree_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name \|\| ‘_delete’
.. Fail if returned sql != result of populating delete trigger template in Annex L using result_set_table_name for <t> and result_set_column_name for <c>
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.3.1.1 Req 92:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/spatial_indexes/implementation/sql_functions+
|*Test Purpose* |Verify the correct implementation of sql functions used in spatial indexes on feature table geometry columns.
|*Test Method* |
. Open Geometry Test Data Set GeoPackage with GeoPackage SQLite Extension
. For each Geometry Test Data Set <gtype_test> data table row for each geometry type in Annex E, for an assortment of srs_ids, for an assortment of coordinate values including empty geometries, without and with z and / or m values, in both big and little endian encodings:
.. SELECT ‘Fail’ FROM <gtype_test> WHERE ST_IsEmpty(geom.) != empty
.. SELECT ‘Fail’ FROM <gtype_test>  WHERE ST_MinX(geom) != minx
.. SELECT ‘Fail’ FROM <gtype_test>  WHERE ST_MaxX(geom) != maxx
.. SELECT ‘Fail’ FROM <gtype_test>  WHERE ST_MinY(geom) != miny
.. SELECT ‘Fail’ FROM <gtype_test>  WHERE ST_MaxY(geom) != maxy
..
. Pass if no ‘Fail’ selected from step 2
|*Reference* |Clause 3.1.3.1.1 Req 92:
|*Test Type* |Capability
|========================================

*Spatial Indexes – Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/spatial_indexes/extension_name+
|*Test Purpose* |Verify that the “gpkg_rtree_index” extension name is used to register spatial index extensions.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if result set is empty
. For each row table_name, column_name from step 3
.. SELECT sql FROM sqlite_master WHERE tbl_name = ‘rtree_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Not testable if returns an empty result set
.. /opt/extension_mechanism/extensions/data/table_def
.. Fail if failed
.. SELECT extension_name from gpkg_extensions WHERE table_name = result_set_table_name AND column_name = result_set_column_name
.. Log pass if result is “gpkg_rtree_index”
.. Fail otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.3.1.2 Req 93:
|*Test Type* |Basic
|========================================

*Spatial Indexes – Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/spatial_indexes/extension_row+
|*Test Purpose* |Verify that spatial index extensions are registered using the “gpkg_rtree_index” name in the gpkg_extensions table.
|*Test Method* |
 /reg_ext/features/spatial_indexes/extension_name
|*Reference* |Clause 3.1.3.1.3 Req 94:
|*Test Type* |Capability
|========================================

===== Geometry Type Triggers
====== Data
*Geometry Type Triggers Implementation*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_type_triggers/implementation+
|*Test Purpose* |Verify that user feature data table geometry type triggers are implemented correctly.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if returns an empty result set
. For each row table_name, column_name from step 1
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tbl_name = ‘fgti_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Not testable if returns an empty result set
.. Fail if sql != result of populating the first trigger template in Annex M with <t> as result_set_table_name and <c> as result_set_column_name
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tbl_name = ‘fgtu_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Fail if sql != result of populating the second trigger template in Annex M with <t> as result_set_table_name and <c> as result_set_column_name
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.4.1.1 Req 95:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_type_triggers/implementation/sql_functions+
|*Test Purpose* |Verify the correct implementation of sql functions used in geometry type triggers on feature table geometry columns.
|*Test Method* |
. Open Geometry Test Data Set GeoPackage with GeoPackage SQLite Extension
. For each Geometry Test Data Set <gtype_test> data table row for each assignable (gtype, atype) and non-assignable (ntype, atype) combination of geometry type in Annex E, for an assortment of srs_ids, for an assortment of coordinate values, without and with z and / or m values, in both big and little endian encodings:
.. SELECT ‘Fail’ FROM <gtype_test> WHERE GPKG_IsAssignable(gtype, atype) =0
.. SELECT ‘Fail’ FROM <gtype_test> WHERE GPKG_IsAssignable(ntype, atype) = 1
.. SELECT ‘Fail’ FROM <gtype_test> WHERE ST_GeometryType(geom) != atype
. Pass if no ‘Fail’ selected from step 2
|*Reference* |Clause 3.1.4.1.1 Req 95:
|*Test Type* |Capability
|========================================

*Geometry Type Triggers – Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_type_triggers/extension_name+
|*Test Purpose* |Verify that the “gpkg_geometry_type_trigger” extension name is used to register geometry type triggers.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if result set is empty
. For each row table_name, column_name from step 1
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tbl_name = ‘fgti_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Not testable if result set is empty
.. /opt/extension_mechanism/extensions/data/table_def
.. Fail if failed
.. SELECT extension_name from gpkg_extensions WHERE table_name = result_set_table_name AND column_name = result_set_column_name
.. Log pass if result is “gpkg_geometry_type_trigger”
.. Fail otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.4.1.2 Req 96:
|*Test Type* |Basic
|========================================

*Geometry Type Triggers – Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/geometry_type_triggers/extension_row+
|*Test Purpose* |Verify that geometry type triggers are registered using the “gpkg_geometry_type_trigger” extension name.
|*Test Method* |
 Do test /reg_ext/features/geometry_type_triggers/extension_name
|*Reference* |Clause 3.1.4.1.3 Req 97:
|*Test Type* |Capability
|========================================

===== SRS_ID Triggers
====== Data
*SRS_ID Triggers – Implementation*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/srs_id_triggers/implementation+
|*Test Purpose* |Verify that user feature data table srs_id triggers are implemented correctly.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if result set is empty
. For each row table_name, column_name from step 1
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tbl_name = ‘fgsi_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Not testable if result set is empty
.. Fail if sql != result of populating the first trigger template in Annex N with <t> as result_set_table_name and <c> as result_set_column_name
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tbl_name = ‘fgsu_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Fail if sql != result of populating the second trigger template in Annex N with <t> as result_set_table_name and <c> as result_set_column_name
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.1.5.1.1 Req 98:
|*Test Type* |Capability
|========================================

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/srs_id_triggers/implementation/sql_functions+
|*Test Purpose* |Verify the correct implementation of sql functions used in srs_id triggers on feature table geometry columns.
|*Test Method* |
. Open Geometry Test Data Set GeoPackage with GeoPackage SQLite Extension
. For each Geometry Test Data Set <gtype_test> data table row for each geometry type in Annex E, for an assortment of srs_ids, for an assortment of coordinate values, without and with z and / or m values, in both big and little endian encodings:
.. SELECT ‘Fail’ FROM <gtype_test> WHERE ST_SRID(geom) != srs_id
. Pass if no ‘Fail’ selected from step 2
|*Reference* |Clause 3.1.5.1.1 Req 98:
|*Test Type* |Capability
|========================================

*SRS_ID Triggers – Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/srs_id_triggers/extension_name+
|*Test Purpose* |Verify that the “gpkg_srs_id_trigger” extension name is used to register srs_id triggers.
|*Test Method* |
. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type  == ‘features'))
. Not testable if result set is empty
. For each row table_name, column_name from step 1
.. SELECT sql FROM sqlite_master WHERE type = ‘trigger’ AND tbl_name = ‘fgsi_’ \|\| result_set_table_name \|\| ‘_’ \|\| result_set_column_name
.. Not testable if result set is empty
.. /opt/extension_mechanism/extensions/data/table_def
.. Fail if failed
.. SELECT extension_name from gpkg_extensions WHERE table_name = result_set_table_name AND column_name = result_set_column_name
.. Pass if result is “gpkg_srs_id_trigger”
.. Fail otherwise
|*Reference* |Clause 3.1.5.1.2 Req 99:
|*Test Type* |Basic
|========================================

*SRS_ID Triggers – Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/features/srs_id_triggers/extension_row+
|*Test Purpose* |Verify that srs_id triggers are registered using the “gpkg_srs_id_trigger” extension name.
|*Test Method* |
 Do test /reg_ext/features/srs_id_triggers/extension_name
|*Reference* |Clause 3.1.5.1.3 Req 100:
|*Test Type* |Capability
|========================================

==== Tiles
===== Zoom Levels
====== Data
*Zoom Other Intervals—Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/tiles/zoom_levels/data/zoom_other_ext_name+
|*Test Purpose* |Verify that the “gpkg_zoom_other” extension name is used to register tiles tables with other than factors of two zoom intervals.
|*Test Method* |
. SELECT table_name FROM gpkg_contents WHERE data_type = \'tiles'
. Not testable if empty result set
. For each row table_name from step 1
.. SELECT zoom_level, pixel_x_size, pixel_y_size FROM gpkg_tile_matrix WHERE table_name = selected table name ORDER BY zoom_level ASC
.. Not testable if returns empty result set
.. Not testable if there are not two rows with adjacent zoom levels
.. Not testable if no pair of rows for adjacent zoom levels have pixel_x_size or pixel_y_size values that differ by other than factors of two
.. /opt/extension_mechanism/extensions/data/table_def
.. Fail if failed
.. SELECT * FROM gpkg_extensions WHERE table_name = selected table name AND extension_name = \'gpkg_zoom_other'
.. Fail if returns an empty result set
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.2.1.1.1 Req 101:
|*Test Type* |Basic
|========================================

*Zoom Other Intervals – Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/tiles/zoom_levels/data/zoom_other_ext_row+
|*Test Purpose* |Verify that tiles tables with other than factors of two zoom intervals are registered using the “gpkg_zoom_other” extension name.
|*Test Method* |
 /reg_ext/tiles/zoom_levels/data/zoom_other_ext_name
|*Reference* |Clause 3.2.1.1.2 Req 102:
|*Test Type:* |Capability
|========================================

===== Tile Encoding WEBP
====== Data
*WEBP – Extensions Name*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/tiles/tile_encoding_webp/data/webp_ext_name+
|*Test Purpose:* |Verify that the “gpkg_webp” extensions name is used to register WEBP tile encoding implementations.
|*Test Method:* |
. +SELECT table_name FROM gpkg_contents WHERE data_type = \'tiles'+
. Not testable if empty result set
. For each row table_name from step 1
.. Select tile_data FROM row table_name
.. For each row tile_data from step a
... Log webp if tile data in MIME type image/webp
.. Not testable if no logged webps
.. /opt/extension_mechanism/extensions/data/table_def
.. Fail if failed
.. +SELECT * FROM gpkg_extensions WHERE table_name = selected table name AND extension_name = 'gpkg_webp’+
.. Fail if returns an empty result set
.. Log pass otherwise
. Pass if logged pass and no fails
|*Reference* |Clause 3.2.2.2.1 Req 103:
|*Test Type* |Basic
|========================================

*WEBP – Extensions Row*

[cols="1,5a"]
|========================================
|*Test Case ID* |+/reg_ext/tiles/tile_encoding_webp/data/webp_ext_row+
|*Test Purpose:* |Verify that WEBP tile encodings are registered using the “gpkg_webp” extensions name.
|*Test Method:* |	+/reg_ext/tiles/tile_encoding_webp/data/webp_ext_name+
|*Reference:* |Clause 3.2.2.2.2 Req 104:
|*Test Type* |Capability
|========================================
