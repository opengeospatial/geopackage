[[abstract_test_suite]]
[appendix]
== Conformance / Abstract Test Suite (Normative)

*WARNING: This section is not up to date. Please refer to the PDF or Word version of the specification.*

=== Base

==== Core

===== SQLite Container

====== Data

*File Format*

**Test Case ID**: /base/core/container/data/file_format

*Test Purpose*: Verify that the Geopackage file is an SQLite version_3 database

*Test Method*: Pass if the first 16 bytes of the file contain "SQLite format 3" in ASCII.

*Reference*: Clause 1.1.1.1.1 Req 1:

*Test Type*: Basic

*File Extension Name* 

**Test Case ID**: /base/core/container/data/file_extension_name

*Test Purpose*: Verify that the geopackage file extension is ".gpkg"

*Test Method*: Pass if the geopackage file extension is ".gpkg"

*Reference*: Clause 1.1.1.1.2 Req 2:

*Test Type*: Basic
 
*Integrity Check* 

**Test Case ID**: /base/core/container/data/file_integrity

*Test Purpose*: Verify that the geopackage file passes the SQLite integrity check.

*Test Method*: Pass if PRAGMA integrity_check returns "ok"

*Reference*: Clause 1.1.1.1.3 Req 3:

*Test Type*: Capability
 
====== API

*Structured Query Language* 

**Test Case ID**: /base/core/container/api/sql

*Test Purpose*: Test that the GeoPackage SQLite Extension provides the SQLite SQL API
 interface.

*Test Method*:

1. SELECT * FROM sqlite_master
2. Fail if returns an SQL error.
3. Pass otherwise

*Reference*:     Clause 1.1.1.2.1 Req 4:

*Test Type*:     Capability
 
*Every GPKG SQLite Configuration* 

**Test Case ID**: /base/core/container/api/every_gpkg_sqlite_config

*Test Purpose*: Verify that a GeoPackage SQLite Extension has the Every GeoPackage
 SQLite Configuration compile and run time options.

*Test Method*:

1. SELECT sqlite_compileoption_used('SQLITE_OMIT_AUTOINCREMENT')
2.    Fail if returns 1
3.    SELECT sqlite_compileoption_used('SQLITE_OMIT_DATETIME_FUNCS')
4.    Fail if returns 1
5.    SELECT sqlite_compileoption_used('SQLITE_OMIT_ DEPRECATED ')
6.    Fail if returns 0
7.    SELECT sqlite_compileoption_used('SQLITE_OMIT_ FLOATING_POINT ')
8.    Fail if returns 1
9.    SELECT sqlite_compileoption_used('SQLITE_OMIT_PRAGMA')
10.   Fail if returns 1
11.   SELECT sqlite_compileoption_used('SQLITE_OMIT_FLAG_PRAGMAS')
12.   Fail if returns 1
13.   SELECT sqlite_compileoption_used('SQLITE_OMIT_VIEW')
14.   Fail if returns 1
15.   Pass otherwise

*Reference*:     Clause 1.1.1.2.2 Req 5:

*Test Type*:     Basic

===== Spatial Reference Systems

====== Data

*Table Definition* 


**Test Case ID**: /base/core/spatial_ref_sys/data/table_def

*Test Purpose*: Verify that the gpkg_spatial_ref_sys table exists and has the correct definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'gpkg_spatial_ref_sys'
2. Fail if returns an empty result set
3. Pass if column names and column definitions in the returned CREATE TABLE
    statement in the sql column value, including data type, nullability, and
    primary key constraints match all of those in the contents of C.1
    Table 19. Column order, check constraint and trigger definitions, and other column
    definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:     Clause 1.1.2.1.1 Req 6:

*Test Type*:     Basic
 
*Table Data Values* 


**Test Case ID**: /base/core/spatial_ref_sys/data_values_default

*Test Purpose*: Verify that the spatial_ref_sys table contains the required default contents.

*Test Method*:

1. SELECT srid, auth_name, auth_srid, srtext FROM spatial_ref_sys WHERE srid = -1
    returns -1 "NONE" -1 "Undefined", AND
2. SELECT srid, auth_name, auth_srid, srtext FROM spatial_ref_sys WHERE srid = 0
    returns 0 "NONE" 0 "Undefined", AND
3. SELECT srid, auth_name, auth_srid, srtext FROM spatial_ref_sys WHERE srid =
    4326 returns 4326 epsg 4326 GEOGCS["WGS 84", DATUM["WGS_1984",
  SPHEROID["WGS 84",6378137,298.257223563, AUTHORITY["EPSG","7030"]],
  AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","
  8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],
  AUTHORITY["EPSG","4326"]] (whitespace irrelevant)
4. Pass if tests 1-3 are met
5. Fail otherwise

*Reference*:     Clause 1.1.2.1.2 Req 7:

*Test Type*:     Capability


**Test Case ID**: /base/core/spatial_ref_sys/data_values_required

*Test Purpose*: Verify that the spatial_ref_sys table contains rows to define all srs_id values
 used by features and tiles in a GeoPackage.

*Test Method*:

1. SELECT DISTINCT gc.srs_id AS gc_srid, srs.srs_name, srs.srs_id, srs.organization,
  srs.organization_coordsys_id, srs.definition FROM gpkg_contents AS gc LEFT
  OUTER JOIN gpkg_spatial_ref_sys AS srs ON srs.srs_id = gc.srs_id
2. Pass if no returned srs values are NULL.
3. Fail otherwise

*Reference*:     Clause Clause 1.1.2.1.2 Req 7:

===== Test Type: CapabilityContents

======   Data

*Table Definition* 


**Test Case ID**: /base/core/contents/data/table_def

*Test Purpose*: Verify that the gpkg_contents table exists and has the correct definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'gpkg_contents'
2. Fail if returns an empty result set.
3. Pass if the column names and column definitions in the returned CREATE TABLE
  statement, including data type, nullability, default values and primary, foreign and
  unique key constraints match all of those in the contents of C.2 Table 20. Column
  order, check constraint and trigger definitions, and other column definitions in the
  returned sql are irrelevant.
4. Fail Otherwise

*Reference*:     Clause 1.1.3.1.1 Req 9:

*Test Type*:     Basic
 
*Table Data Values* 

**Test Case ID**: /base/core/contents/data/data_values_table_name

*Test Purpose*: Verify that the table_name column values in the gpkg_contents table are
 valid.

*Test Method*:

1. SELECT DISTINCT gc.table_name AS gc_table, sm.tbl_name
FROM gpkg_contents AS ge LEFT OUTER JOIN sqlite_master AS sm ON
gc.table_name = sm.tbl_name
2. Not testable if returns an empty result set.
3. Fail if any gpkg_contents.table_name value is NULL
4. Pass otherwise.

*Reference*:    Clause 1.1.3.1.2 Req 10:

*Test Type*:    Capability



**Test Case ID**: /base/core/contents/data/data_values_last_change

*Test Purpose*: Verify that the gpkg_contents table last_change column values are in ISO
 8601 [41]format containing a complete date plus UTC hours, minutes, seconds and a
 decimal fraction of a second, with a 'Z' ('zulu') suffix indicating UTC.

*Test Method*:

1. SELECT last_change from gpkg_contents.
2. Not testable if returns an empty result set.
3. For each row from step 1
  - Fail if format of returned value does not match yyyy-mm-ddThh:mm:ss.hhhZ
  - Log pass otherwise
4. Pass if logged pass and no fails.

*Reference*:    Clause 1.1.3.1.2 Req 11:

*Test Type*:    Capability



**Test Case ID**: /base/core/contents/data/data_values_srs_id

*Test Purpose*: Verify that the gpkg_contents table srs_id column values are defined in the
 gpkg_spatial_ref_sys table.

*Test Method*:

1. SELECT srs_id FROM gpkg_contents
2. Not testable if returns an empty result set
3. SELECT srs_id FROM gpkg_contents WHERE srs_id NOT IN (SELECT srs_id
  FROM gpkg_spatial_ref_sys)
4. Fail if does not return an empty result set
5. SELECT srs_id FROM gpkg_contents gc WHERE data_type = 'features' AND srs_id
  NOT IN (SELECT srs_id FROM gpkg_geometry_columns WHERE table_name =
  gc.table_name)
6. Fail if does not return an empty result set
7. Pass otherwise

*Reference*:    Clause Clause 1.1.3.1.2 Req 12:

*Test Type*:    Capability


=== Options


**Test Case ID**: /opt/valid_geopackage

*Test Purpose*: Verify that a GeoPackage contains a features or tiles table and gpkg_contents
 table row describing it.

*Test Method*:

1.   Execute test /opt/features/contents/data/features_row
2.   Pass if test passed
3.   Execute test /opt/tiles/contents/data/tiles_row
4.   Pass if test passed
5.   Fail otherwise

*Reference*:     Clause 2 Req 13:

*Test Type*:     Capability
 
==== Features

===== Contents

======   Data

*Contents Table Feature Row* 


**Test Case ID**: /opt/features/contents/data/features_row

*Test Purpose*: Verify that the gpkg_contents table_name value table exists, and is
 apparently a feature table for every row with a data_type column value of "features"

*Test Method*:

1. Execute test /opt/features/vector_features/data/feature_table_integer_primary_key

*Reference*:     Clause 2.1.2.1.1 Req 14:

*Test Type*:     Capability
 
===== Geometry Encoding

======   Data

*BLOB Format* 


**Test Case ID**: /opt/features/geometry_encoding/data/blob

*Test Purpose*: Verify that geometries stored in feature table geometry columns are encoded
 in the GeoPackageBinary format.

*Test Method*:

1. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns
  WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE
  data_type = 'features')
2. Not testable if returns an empty result set
3. For each row from step 1
  * SELECT cn FROM tn
  * Not testable if none found
  * For each cn value from step a
      -  Fail if the first three bytes of each gc are not "GPB"
      -  Fail if gc.version_number is not 0
      -  Fail if ST_IsEmpty(cn value) = 1 and gc.flags.envelope != 0 and envelope values are not NaN
4. Pass if no fails

*Reference*:    Clause 2.1.3.1.1 Req 15:

*Test Type*:    Capability
 
======   API

*Minimal Runtime SQL Functions* 


**Test Case ID**: /opt/features/geometry_encoding/sql_func

*Test Purpose*: Verify that a GeoPackage SQLite Extension provides the GeoPackage
 Minimal Runtime SQL functions.

*Test Method*:

1. Open Geometry Test Data Set GeoPackage with GeoPackage SQLite Extension
2. For each Geometry Test Data Set &lt;gtype_test&gt; data table row for each assignable
      (gtype, atype) and non-assignable (ntype, atype) combination of geometry type in
      Annex G, for an assortment of srs_ids, for an assortment of coordinate values,
      without and with z and / or m values, in both big and little endian encodings:
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_SRID(geom) != srs_id
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_GeometryType(geom) !=
          atype
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE GPKG_IsAssignable(gtype,
          atype) = 0
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE GPKG_IsAssignable(ntype,
          atype) = 1
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_Is3D(geom) != is3d
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_IsMeasured(geom) != ism
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MinX(geom) != minx
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MaxX(geom) != maxx
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MinY(geom) != miny
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MaxY(geom) != maxy
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MinZ(geom) != minz
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MaxZ(geom) != maxz
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MinM(geom) != minm
      - SELECT 'Fail' FROM &lt;gtype_test&gt; WHERE ST_MaxM(geom) != maxm
3. Pass if no 'Fail' selected from step 2

*Reference*:    Clause 2.1.3.2.1 Req 16:

*Test Type*:    Capability
 
===== Geometry Types

======  Data

*Core Types* 

**Test Case ID**: /opt/features/geometry_encoding/data/core_types_existing_sparse_data

*Test Purpose*: Verify that existing basic simple feature geometries are stored in valid GeoPackageBinary format encodings.

*Test Method*:

1. SELECT table_name FROM gpkg_geometry_columns
2. Not testable if returns an empty result set
3. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns
    WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE
    data_type = 'features'),
4. Fail if returns an empty result set
5. For each row from step 3
     - SELECT cn FROM tn;
     - For each row from step a, if bytes 2-5 of cn.wkb as uint32 in endianness of
            gc.wkb byte 1of cn from #1 are a geometry type value from Annex G Table 46,
            then
         +     Log cn.header values, wkb endianness and geometry type
         +     If cn.wkb is not correctly encoded per ISO 13249-3 clause 5.1.46 then log
                fail
         +      If cn.flags.E is 1 - 4 and some cn.wkbx is outside of cn.envelope.minx,maxx
                then log fail
         +      If cn.flags.E is 1 - 4 and some gc.wkby is outside of cn.envelope.miny,maxy
                then log fail
         +      If cn.flags.E is 2,4 and some gc.wkb.z is outside of cnenvelope.minz,maxz
                then log fail
         +      If cn.flags.E is 3,4 and some gc.wkb.m is outside of cn.envelope.minm,maxm
                then log fail
         +      If cn.flags.E is 5-7 then log fail
         +      Otherwise log pass

6. Pass if log contanins pass and no fails

*Reference*:     Clause 2.1.4.1.1 Req 17:

*Test Type*:     Capability


**Test Case ID**: /opt/features/geometry_encoding/data/core_types_all_types_test_data

*Test Purpose*: Verify that all basic simple feature geometry types and options are stored in valid GeoPackageBinary format encodings.

*Test Method*:

1. Open GeoPackage that has feature geometry values of geometry type in Annex G, for
  an assortment of srs_ids, for an assortment of coordinate values, without and with z
  and / or m values, in both big and little endian encodings:
2. /opt/features/geometry_encoding/data/core_types_existing_sparse_data
3. Pass if log contains pass record for big and little endian GPB headers containing big
  and little endian WKBs for 0-1 envelope contents indicator codes for every geometry
  type value from Annex G Table 46 without and with z and/or m values.
4. Fail otherwise

*Reference*:     Clause 2.1.4.1.1 Req 17:

*Test Type*:     Capability
 
===== Geometry Columns

====== Data

*Table Definition* 


**Test Case ID**: /opt/features/geometry_columns/data/table_def

*Test Purpose*: Verify that the gpkg_geometry_columns table exists and has the correct
 definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name =
    'gpkg_geometry_columns'
2. Fail if returns an empty result set.
3. Pass if the column names and column definitions in the returned Create TABLE
    statement in the sql column value, including data type, nullability, default values and
    primary, foreign and unique key constraints match all of those in the contents of C.4
    Table 22. Column order, check constraint and trigger definitions, and other column
    definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:     Clause 2.1.5.1.1 Req 18:

*Test Type*:     Basic
 
*Table Data Values* 


**Test Case ID**: /opt/features/geometry_columns/data/data_values_table_name

*Test Purpose*: Verify that the table_name column values in the gpkg_geometry_columns
 table are valid.

*Test Method*:

1. SELECT DISTINCT table_name FROM gpkg_geometry_columns
2. Not testable if returns an empty result set.
3. For each row from setp 1
    - Fail if table_name value is NULL
4. SELECT DISTINCT ggc.table_name AS ggc_table, gc.table_name
    FROM gpkg_geometry_columns AS ggc LEFT OUTER JOIN geopackage_contents
    AS gc ON ggc.table_name = gc.table_name
5. For each row from step 4
    - Fail if ggc.table_name != gc.table_name
6. Pass if no fails.

*Reference*:     Clause 2.1.5.1.2 Req 19:

*Test Type*:     Capability



**Test Case ID**: /opt/features/geometry_columns/data/data_values_column_name

*Test Purpose*: Verify that the column_name column values in the gpkg_geometry_columns
table are valid.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns
2. Not testable if returns an empty result set
3. For each row from step 1
    - PRAGMA table_info(table_name)
    - Fail if gpkg_geometry_columns.column_name value does not equal a name
	column value returned by PRAGMA table_info.

Pass if no fails.

*Reference*:   Clause 2.1.5.1.2 Req 20:

*Test Type*: Capability


**Test Case ID**: /opt/features/geometry_columns/data/data_values_geometry_type_name

*Test Purpose*: Verrify that the geometry_type_name column values in the
gpkg_geometry_columns table are valid.

*Test Method*:

1. SELECT DISTINCT geometry_type_name from gpkg_geometry_columns
2. Not testable if returns an empty result set
3. For each row from step 1
    - Fail if a returned geometry_type value is not in Table 46 or Table 47 in Annex G
4. Pass if no fails.

*Reference*:     Clause 2.1.5.1.2 Req 21:

*Test Type*:     Capability


**Test Case ID**: /opt/features/geometry_columns/data/data_values_srs_id

*Test Purpose*: Verify that the gpkg_geometry_columns table srs_id column values are
defined in the gpkg_spatial_ref_sys table.

*Test Method*:

1. SELECT srs_id FROM gpkg_geometry_columns
2. Not testable if returns an empty result set
3. SELECT srs_id FROM gpkg_geometry_columns WHERE srs_id NOT IN (SELECT
    srs_id FROM gpkg_spatial_ref_sys)
4. Fail if does not return an empty result set
5. Pass otherwise.

*Reference*:     Clause 2.1.5.1.2 Req 22:

*Test Type*:     Capability


**Test Case ID**: /opt/features/geometry_columns/data/data_values_z

*Test Purpose*: Verify that the gpkg_geometry_columns table z column values are valid.

*Test Method*:

1.   SELECT z FROM gpkg_geometry_columns
2.   Not testable if returns an empty result set
3.   SELECT z FROM gpkg_geometry_columns WHERE z NOT IN (1,2,3)
4.   Fail if does not return an empty result set
5.   Pass otherwise.

*Reference*:     Clause 2.1.5.1.2 Req 23:

*Test Type*:     Capability



**Test Case ID**: /opt/features/geometry_columns/data/data_values_m

*Test Purpose*: Verify that the gpkg_geometry_columns table m column values are valid.

*Test Method*:

1.   SELECT m FROM gpkg_geometry_columns
2.   Not testable if returns an empty result set
3.   SELECT m FROM gpkg_geometry_columns WHERE m NOT IN (1,2,3)
4.   Fail if does not return an empty result set
5.   Pass otherwise.

*Reference*:     Clause 2.1.5.1.2 Req 24:

*Test Type*:     Capability


===== Vector Features User Data Tables

====== Data

*Table Definition* 


**Test Case ID**: /opt/features/vector_features/data/feature_table_integer_primary_key

*Test Purpose*: Verify that every vector features user data table has an integer primary key.

*Test Method*:

1. SELECT table_name FROM gpkg_contents WERE data_type = 'features'
2. Not testable if returns an empty result set
3. For each row from step 1
   - PRAGMA table_info(table_name)
   - Fail if returns an empty result set
   - Fail if result set does not contain one row where the pk column value is 1 and the not
       null column value is 1 and the type column value is "INTEGER"
4. Pass if no fails.

*Reference*:     Clause 2.1.6.1.1 Req 25:

*Test Type*:     Basic

**Test Case ID**: /opt/features/vector/features/data/feature_table_one_geometry_column

*Test Purpose*: Verify that every vector features user data table has one geometry column.

*Test Method*:

1. SELECT table_name FROM gpkg_contents WERE data_type = 'features'
2. Not testable if returns an empty result set
3. For each row table name from step 1
   - SELECT column_name from gpkg_geometry_columns where table_name = row
       table name
   - Fail if returns more than one column name
4. Pass if no fails
  
*Reference*: Clause 2.1.6.1.1 Req 26:
  
*Test Type*: Capability

*Table Data Values* 

**Test Case ID**: /opt/features/vector_features/data/data_values_geometry_type

*Test Purpose*: Verify that the geometry type of feature geometries are of the type or are
 assignable for the geometry type specified by the gpkg_geometry columns table
 geometry_type_name column value.

*Test Method*:

1. SELECT table_name AS tn, column_name AS cn, geometry_type_name AS gt_name
  FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name
  FROM gpkg_contents WHERE data_type = 'features')
2. Not testable if returns an empty result set
3. For each row from step 1
  - SELECT DISTINCT ST_GeometryType(cn) FROM tn
  - For each row actual_type_name from step a
      +    SELECT GPKG_IsAssignable(geometry_type_name, actual_type_name)
      +    Fail if any returned 0
4. Pass if no fails

*Reference*:     Clause 2.1.6.1.2 Req 27:

*Test Type*:     Capability



**Test Case ID**: /opt/features/vector_features/data/tata_value_geometry_srs_id

*Test Purpose*: Verify the the srs_id of feature geometries are the srs_id specified for the
 gpkg_geometry_columns table srs_id column value.

*Test Method*:

1. SELECT table_name AS tn, column_name AS cn, srs_id AS gc_srs_id FROM
  gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM
  gpkg_contents where data_type = 'features')
2. Not testable if returns an empty result set
3. For each row from step 1
  - SELECT DISTINCT st_srid(cn) FROM tn
  - For each row from step a
    +     Fail if returnvalue not equal to gc_srs_id
4. Pass if no fails

*Reference*:     Clause 2.1.6.1.2 Req 28:

*Test Type*:     Capability
 
==== Tiles

===== Contents

======   Data

*Contents Table - Tiles Row* 


**Test Case ID**: /opt/tiles/contents/data/tiles_row

*Test Purpose*: Verify that the gpkg_contents table_name value table exists and is apparently
 a tiles table for every row with a data_type column value of "tiles".

*Test Method*:

1. SELECT table_name FROM gpkg_contents WHERE data_type = "tiles"
2. Fail if returns empty result set
3. For each row from step 1
  - PRAGMA table_info(table_name)
  - Fail if returns an empty result set
  - Fail if result set does not contain one row where the pk column value is 1 and the
      not null column value is 1 and the type column value is "INTEGER"and the
      name column value is "id"
  - Fail if result set does not contain four other rows where the name column values
      are "zoom_level","tile_column","tile_row", and "tile_data".
4. Pass if no fails.

*Reference*:     Clause 2.2.2.1.1 Req 29:

*Test Type*:     Capability
 
===== Zoom Levels

======   Data

*Zoom Times Two* 


**Test Case ID**: /opt/tiles/zoom_levels_data_zoom_times_two

*Test Purpose*: Verify that by default zoom level pixel sizes for tile matrix user data tables
 vary by factors of 2 between adjacent zoom levels in the tile matrix metadata table.

*Test Method*:

1. SELECT CASE
  WHEN (SELECT tbl_name FROM sqlite_master WHERE tbl_name =
  'gpkg_extensions') = 'gpkg_extensions' THEN
  (SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles' AND
  table_name NOT IN
    (SELECT table_name from gpkg_extensions WHERE extension_name =
  'gpkg_zoom_other'))
  ELSE (SELECT table_name FROM geopackage_contents WHERE data_type =
  'tiles')
  END;
2. Not testable if returns empty result set
3. For each row table_name from step 1
  - SELECT zoom_level, pixel_x_size, pixel_y_size FROM tile_matrix_metadata
	WHERE table_name = selected table name ORDER BY zoom_level ASC
  - Not testable if returns empty result set, or only one row
  - Not testable if there are not two rows with adjacent zoom levels
  - Fail if any pair of rows for adjacent zoom levels have pixel_x_size or
      pixel_y_size values that differ by other than factors of two
4. Pass if no fails

*Reference*:      Clause 2.2.3.1.1 Req 30:

*Test Type*:      Capability

===== Tile Encoding PNG

====== Data

*MIME Type PNG* 


**Test Case ID**: /opt/tiles/tiles_encoding/data/mime_type_png

*Test Purpose*: Verify that a tile matrix user data table that contains tile data that is not
 MIME type image/jpeg by default contains tile data in MIME type image/png.

*Test Method*:

1. SELECT CASE
    WHEN (SELECT tbl_name FROM sqlite_master WHERE tbl_name =
    'gpkg_extensions') = 'gpkg_extensions' THEN
    (SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles' AND
    table_name NOT IN
    (SELECT table_name from gpkg_extensions WHERE extension_name IN
    ('gpkg_webp','gpkg_tiff','gpkg_nitf')))
    ELSE (SELECT table_name FROM geopackage_contents WHERE data_type =
    'tiles')
    END;
2. Not testable if returns empty result set
3. For each row tbl_name from step 1
    - SELECT tile_data FROM tbl_name
    - For each row tile_data from step a
	+ Pass if tile data in MIME type image/png
4. Fail if no passes

*Reference*:      Clause 2.2.4.1.1 Req 31:

*Test Type*:      Capability
 
===== Tile Encoding JPEG

====== Data

*MIME Type JPEG* 


**Test Case ID**: /opt/tiles/tiles_encoding/data/mime_type_jpeg

*Test Purpose*: Verify that a tile matrix user data table that contains tile data that is not
 MIME type image/png by default contains tile data in MIME type image/jpeg.

*Test Method*:

1. SELECT CASE
  WHEN (SELECT tbl_name FROM sqlite_master WHERE tbl_name =
  'gpkg_extensions') = 'gpkg_extensions' THEN
  (SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles' AND
  table_name NOT IN
    (SELECT table_name from gpkg_extensions WHERE extension_name IN
  ('gpkg_webp','gpkg_tiff','gpkg_nitf')))
  ELSE (SELECT table_name FROM geopackage_contents WHERE data_type =
  'tiles')
  END;
2. Not testable if returns empty result set
3. For each row tbl_name from step 1
  - SELECT tile_data FROM tbl_name
  - For each row tile_data from step a
      +   Pass if tile data in MIME type image/jpeg
4. Fail if no passes

*Reference*:    Clause 2.2.5.1.1 Req 32:

*Test Type*:    Capability
 
===== Tile Matrix Metadata

====== Data

*Table Definition* 


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/table_def

*Test Purpose*: Verify that the gpkg_tile_matrix_metadata table exists and has the correct
 definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name =
  'gpkg_tile_matrix_metadata'
2. Fail if returns an empty result set.
3. Pass if the column names and column definitions in the returned CREATE TABLE
  statement in the sql column value,, including data type, nullability, default values and
  primary, foreign and unique key constraints match all of those in the contents of C.7
  Table 25. Column order, check constraint and trigger definitions, and other column
  definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:    Clause 2.2.6.1.1 Req 33:

*Test Type*:    Basic


*Table Data Values* 

**Test Case ID**: /opt/tiles/tile_matrix_metadata/data_values_table_name

*Test Purpose*: Verify that values of the gpkg_tile_matrix_metadata table_name column
 reference values in the gpkg_contents table_name column for rows with a data type of
 "tiles".

*Test Method*:

1. SELECT table_name FROM gpkg_tile_matrix_metadata
2. Not testable if returns an empty result set
3. SELECT table_name FROM gpkg_tile_matrix_metadata tmm WHERE table_name
    NOT IN (SELECT table_name FROM gpkg_contents gc WHERE tmm.table_name =
    gc.table_name)
4. Fail if result set contains any rows
5. Pass otherwise
  
*Reference*:    Clause 2.2.6.1.2 Req 34:

*Test Type*:    Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_zoom_level_rows

*Test Purpose*: Verify that the gpkg_tile_matrix_metadata table contains a row record for
each zoom level that contains one or more tiles in each tile matrix user data table.

*Test Method*:

1. SELECT table_name AS &lt;user_data_tiles_table&gt; from gpkg_contents where
    data_type = 'tiles'
2. Not testable if returns an empty result set
3. For each row from step 1
    - SELECT DISTINCT gtmm.zoom_level AS gtmm_zoom, udt.zoom_level AS
	udtt_zoom FROM tile_matrix_metadata AS gtmm
	LEFT OUTER JOIN &lt;user_data_tiles_table&gt; AS udtt ON udtt.zoom_level =
	gtmm.zoom_level AND gtmm.t_table_name = '&lt;user_data_tiles_table&gt;'
    - Fail if any gtmm_zoom column value in the result set is NULL
4. Pass if no fails

*Reference*:    Clause 2.2.6.1.2 Req 35:

*Test Type*:    Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_zoom_level

*Test Purpose*: Verify that zoom level column values in the gpkg_tile_matrix_metadata table
are not negative.

*Test Method*:

1.   SELECT zoom_level FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(zoom_level) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 0.
5.   Pass otherwise.

*Reference*:    Clause 2.2.6.1.2 Req 36:

*Test Type*:    Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_matrix_width

*Test Purpose*: Verify that the matrix_width values in the gpkg_tile_matrix_metadata table
are valid.

*Test Method*:

1.   SELECT matrix_width FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(matrix_width) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 1.
5.   Pass otherwise.

*Reference*:     Clause 2.2.6.1.2 Req 37:

*Test Type*:     Capabilty


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_matrix_height

*Test Purpose*: Verify that the matrix_height values in the gpkg_tile_matrix_metadata table
are valid.

*Test Method*:

1.   SELECT matrix_height FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(matrix_height) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 1.
5.   Pass otherwise.

*Reference*:     Clause 2.2.6.1.2 Req 38:

*Test Type*:     Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_tile_width

*Test Purpose*: Verify that the tile_width values in the gpkg_tile_matrix_metadata table are
valid.

*Test Method*:

1.   SELECT tile_width FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(tile_width) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 1.
5.   Pass otherwise.

*Reference*:     Clause 2.2.6.1.2 Req 39:

*Test Type*:     Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_tile_height

*Test Purpose*: Verify that the tile_height values in the gpkg_tile_matrix_metadata table are
valid.

*Test Method*:

1. SELECT tile_height FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(tile_height) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 1.
5.   Pass otherwise.

*Reference*:    Clause 2.2.6.1.2 Req 40:

*Test Type*:    Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_pixel_x_size

*Test Purpose*: Verify that the pixel_x_size values in the gpkg_tile_matrix_metadata table
are valid.

*Test Method*:

1.   SELECT pixel_x_size FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(pixel_x_size) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 0.
5.   Pass otherwise.

*Reference*:    Clause 2.2.6.1.2 Req 41:

*Test Type*:    Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_pixel_y_size

*Test Purpose*: Verify that the pixel_y_size values in the gpkg_tile_matrix_metadata table
are valid.

*Test Method*:

1.   SELECT pixel_y_size FROM gpkg_tile_matrix_metadata
2.   Not testable if returns an empty result set
3.   SELECT min(pixel_y_size) FROM gpkg_tile_matrix_metadata.
4.   Fail if less than 0.
5.   Pass otherwise.

*Reference*:    Clause 2.2.6.1.2 Req 42:

*Test Type*:    Capability


**Test Case ID**: /opt/tiles/tile_matrix_metadata/data/data_values_pixel_size_sort

*Test Purpose*: Verify that the pixel_x_size and pixel_y_size column values for zoom level
column values in a gpkg_tile_matrix_metadata table sorted in ascending order are sorted in
descending order, showing that lower zoom levels are zoomed "out".

*Test Method*:

1. SELECT table_name FROM gpkg_contents WHERE data_type = 'tiles'
2. Not testable if returns empty result set
3. For each row table_name from step 1
    - SELECT zoom_level, pixel_x_size, pixel_y_size from
	gpkg_tile_matrix_metadata WHERE table_name = row table name ORDER BY
	zoom_level ASC
    - Not testable if returns empty result set
    - Fail if pixel_x_sizes are not sorted in descending order
    - Fail if pixel_y_sizes are not sorted in descending order
4. Pass if testable and no fails

*Reference*:     Clause 2.2.6.1.2 Req 43:

*Test Type*:     Capability

===== Tile Matrix User Data

====== Data

*Table Definition* 


**Test Case ID**: /opt/tiles/tile_matrix/data/table_def

*Test Purpose*: Verify that multiple tile matrix sets are stored in different tiles tables with
 unique names containing the required columns.

*Test Method*:

1. SELECT COUNT(table_name) FROM gpkg_contents WERE data_type = "tiles"
2. Fail if less than 2
3. SELECT table_name FROM gpkg_contents WHERE data_type = "tiles"
4. For each row from step 3
    - PRAGMA table_info(table_name)
    - Fail if returns an empty result set
    - Fail if result set does not contain one row where the pk column value is 1 and the
	not null column value is 1 and the type column value is "INTEGER"and the
	name column value is "id"
    - Fail if result set does not contain four other rows where the name column values
	are "zoom_level","tile_column","tile_row", and "tile_data".
5. Pass if no fails

*Reference*:     Clause 2.2.7.1.1 Req 44:

*Test Type*:     Basic
 
*Table Data Values* 


**Test Case ID**: /opt/tiles/tile_matrix/data/data_values_zoom_levels

*Test Purpose*: Verify that the zoom level column values in each tile matrix user data table
 are within the range of zoom levels defined by rows in the tile_matrix_metadata table.

*Test Method*:

1. SELECT DISTINCT table_name AS &lt;user_data_tiles_table&gt; FROM
  gpkg_tile_matrix_metadata
2. Not testable if returns an empty result set
3. For each row &lt;user_data_tiles_table&gt; from step 1
      - SELECT zoom_level FROM &lt;user_data_tiles_table&gt;
      - If result set not empty
	  + SELECT MIN(gtmm.zoom_level) AS min_gtmm_zoom,
		  MAX(gtmm.zoom_level) AS max_gtmm_zoom FROM
		  gpkg_tile_matrix_metadata WHERE table_name =
		  &lt;user_data_tiles_table&gt;
	  + SELECT id FROM &lt;user_data_tiles_table&gt; WHERE zoom_level &lt;
		  min_gtmm_zoom
	  + Fail if result set not empty
	  + SELECT id FROM &lt;user_data_tiles_table&gt; WHERE zoom_level &gt;
		  max_gtmm_zoom
	  + Fail if result set not empty
	  + Log pass otherwise
4. Pass if logged pas and no fails

*Reference*:     Clause 2.2.7.1.2 Req 45:

*Test Type*:     Capability


**Test Case ID**: /opt/tiles/tile_matrix/data/data_values_tile_column

*Test Purpose*: Verify that the tile_column column values for each zoom level value in each
tile matrix user data table are within the range of columns defined by rows in the
tile_matrix_metadata table.

*Test Method*:

1. SELECT DISTINCT table_name AS &lt;user_data_tiles_table&gt; FROM
    gpkg_tile_matrix_metadata
2. Not testable if returns an empty result set
3. For each row &lt;user_data_tiles_table&gt; from step 1
      + SELECT DISTINCT gtmm.zoom_level AS gtmm_zoom, gtmm.matrix_width
	    AS gtmm_width, udt.zoom_level AS udt_zoom, udt.tile_column AS
	    udt_column FROM tile_matrix_metadata AS gtmm LEFT OUTER JOIN
	    &lt;user_data_tiles_table&gt; AS udt ON udt.zoom_level = gtmm.zoom_level AND
	    gtmm.t_table_name = '&lt;user_data_tiles_table&gt;' AND (udt_column &lt; 0 OR
	    udt_column &gt; (gtmm_width - 1))
      + Fail if any udt_column value in the result set is not NULL
      + Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 2.2.7.1.2 Req 46:

*Test Type*:     Capability

**Test Case ID**: /opt/tiles/tile_matrix_data/data_values_tile_row

*Test Purpose*: Verify that the tile_row column values for each zoom level value in each tile
matrix user data table are within the range of rows defined by rows in the
tile_matrix_metadata table.

*Test Method*:

1. SELECT DISTINCT table_name AS &lt;user_data_tiles_table&gt; FROM
  gpkg_tile_matrix_metadata
2. Not testable if returns an empty result set
3. For each row &lt;user_data_tiles_table&gt; from step 1
      + SELECT DISTINCT gtmm.zoom_level AS gtmm_zoom, gtmm.matrix_height
	  AS gtmm_height, udt.zoom_level AS udt_zoom, udt.tile_row AS udt_row
	  FROM tile_matrix_metadata AS gtmm LEFT OUTER JOIN
	  &lt;user_data_tiles_table&gt; AS udt ON udt.zoom_level = gtmm.zoom_level AND
	  gtmm.t_table_name = '&lt;user_data_tiles_table&gt; ' AND (udt_row &lt; 0 OR
	  udt_row &gt; (gtmm_height - 1))
      + Fail if any udt_row value in the result set is not NULL
      + Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 2.2.7.1.2 Req 47:

*Test Type*:     Capability

==== Schema

===== Data Columns

====== Data

*Table Definition* 

**Test Case ID**: /opt/schema/data_columns/data_table_def

*Test Purpose*: Verify that the gpkg_data_columns table exists and has the correct definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'gpkg_data_columns'
2. Fail if returns an empty result set
3. Pass if column names and column definitions in the returned CREATE TABLE
    statement in the sql column value, including data type, nullability, default values and
    primary, foreign and unique key constraints match all of those in the contents of C.1
    Table 32. Column order, check constraint and trigger definitions, and other column
    definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:     Clause 2.3.1.1.1 Req 48:

*Test Type*:     Basic

*Data Values* 

**Test Case ID**: /opt/schema/data_columns/data/data_values_table_name

*Test Purpose*: Verify that values of the gpkg_data_columns table_name column reference
 values in the gpkg_contents table_name column.

*Test Method*:

1. SELECT table_name FROM gpkg_data columns
2. Not testable if returns an empty result set
3. SELECT table_name FROM gpkg_data_columns gdc WHERE table_name NOT IN
    (SELECT table_name FROM gpkg_contents gc WHERE gdc.table_name =
    gc.t_table_name)
4. Fail if result set contains any rows
5. Pass otherwise

*Reference*:     Clause 2.3.1.1.2 Req 49:

*Test Type*:     Capability



**Test Case ID**: /opt/schema/data_columns/data/data_values_column_name

*Test Purpose*: Verify that for each gpkg_data_columns row, the column_name value is the
 name of a column in the table_name table.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_data_columns
2. Not testable if returns an empty result set
3. For each row from step 1
    + PRAGMA table_info(table_name)
    + Fail if gpkg_data_columns.column_name value does not equal a name column
	value returned by PRAGMA table_info.
4. Pass if no fails.

*Reference*:     Clause 2.3.1.1.2 Req 50:

*Test Type*:     Capability


==== Metadata

===== Metadata Table

====== Data

*Table Definition* 


**Test Case ID**: /opt/metadata/metadata/data/table_def

*Test Purpose*: Verify that the gpkg_metadata table exists and has the correct definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'gpkg_metadata'
2. Fail if returns an empty result set.
3. Pass if the column names and column definitions in the returned Create TABLE
    statement in the sql column value, including data type, nullability, default values and
    primary, foreign and unique key constraints match all of those in the contents of
    Table 33. Column order, check constraint and trigger definitions, and other column
    definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:     Clause 2.4.2.1.1 Req 51:

*Test Type*:     Basic
 
*Table Data Values* 


**Test Case ID**: /opt/metadata/metadata/data/data_values_md_scope

*Test Purpose*: Verify that each of the md_scope column values in a gpkg_metadata table is
 one of the name column values from Table 11 in clause 2.4.2.1.2.

*Test Method*:

1. SELECT md_scope FROM gpkg_metadata
2. Not testable if returns an empty result set
3. For each row returned from step 1
  - Fail if md_scope value not one of the name column values from Table 11 in clause 2.4.2.1.2
4. Pass if no fails

*Reference*:    Clause 2.4.2.1.2 Req 52:

*Test Type*:    Capabilities

===== Metadata Reference Table

====== Data

*Table Definition* 


**Test Case ID**: /opt/metadata/metadata_reference_data_table_def

*Test Purpose*: Verify that the gpkg_metadata_reference table exists and has the correct
 definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'gpkg_metadata_reference'
2. Fail if returns an empty result set.
3. Pass if the column names and column definitions in the returned Create TABLE
  statement in the sql column value, including data type, nullability, default values and
  primary, foreign and unique key constraints match all of those in the contents of
  Table 34. Column order, check constraint and trigger definitions, and other column
  definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:    Clause 2.4.3.1.1 Req 53:

*Test Type*:    Basic

*Data Values* 


**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_reference_scope

*Test Purpose*: Verify that gpkg_metadata_reference table reference_scope column values
 are valid.

*Test Method*:

1. SELECT reference_scope FROM gpkg_metadata_reference
2. Not testable if returns an empty result set
3. SELECT reference_scope FROM gpkg_metadata_reference WHERE
  reference_scope NOT IN ('geopackage','table','column','row','row/col')
4. Fail if does not return an empty result set
5. Pass otherwise.

*Reference*:    Clause 2.4.3.1.2 Req 54:

*Test Type*:    Capability



**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_table_name

*Test Purpose*: Verify that gpkg_metadata_reference table_name column values are NULL
for rows with reference_scope values of 'geopackage', and reference gpkg_contents
table_name values for all other reference_scope values.

*Test Method*:

1. SELECT table_name FROM gpkg_metadata_reference
2. Not testable if returns an empty result set
3. SELECT table_name FROM gpkg_metadata_reference WHERE reference_scope = 'geopackage'
4. Fail if result set contains any non-NULL values
5. SELECT table_name FROM metadata_reference WHERE reference_scope != 'geopackage' AND table_name NOT IN (SELECT table_name FROM gpkg_contents)
6. Fail if result set is not empty
7. Pass otherwise.

*Reference*:    Clause 2.4.3.1.2 Req 55:

*Test Type*:    Capability


**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_column_name

*Test Purpose*: Verify that gpkg_metadata_reference column_name column values are
NULL for rows with reference scope values of 'geopackage', 'table', or 'row', and contain
the name of a column in table_name table for other reference scope values.

*Test Method*:

1. SELECT column_name FROM gpkg_metadata_reference
2. Not testable if returns an empty result set
3. SELECT column_name FROM gpkg_metadata_reference WHERE reference_scope
    IN ('geopackage', 'table', 'row')
4. Fail if result set contains any non-NULL values
5. SELECT &lt;table_name&gt;, &lt;column_name&gt; FROM metadata_reference WHERE
    reference_scope NOT IN ('geopackage', 'table', 'row')
6. For each row from step 5
    - SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = '&lt;table_name&gt;'
    - Fail if returns an empty result set.
    - Fail if the one of the column names in the returned sql Create TABLE statement
	is not &lt;column_name&gt;
    - Log pass otherwise
7. Pass if logged pass and no fails.

*Reference*:    Clause 2.4.3.1.2 Req 56:

*Test Type*:    Capability


**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_row_id_value

*Test Purpose*: Verify that gpkg_metadata_reference row_id_value column values are NULL
for rows with reference scope values of 'geopackage', 'table', or 'row', and contain the
ROWID of a row in the table_name for other reference scope values.

*Test Method*:

1. SELECT row_id_value FROM gpkg_metadata_reference
2. Not testable if returns an empty result set
3. SELECT row_id_value FROM gpkg_metadata_reference WHERE reference_scope
    IN ('geopackage', 'table', 'row')
4. Fail if result set contains any non-NULL values
5. For each SELECT &lt;table_name&gt;, &lt;row_id_value&gt; FROM gpkg_metadata_reference
    WHERE reference_scope NOT IN ('geopackage', 'table', 'row')
6. For each row from step 5
    - SELECT * FROM &lt;table_name&gt; WHERE ROWID = &lt;row_id_value&gt;
    - Fail if result set is empty
    - Log pass otherwise
7. Pass if logged pass and no fails.

*Reference*:    Clause 2.4.3.1.2 Req 57:

*Test Type*:    Capability


**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_timestamp

*Test Purpose*: Verify that every gpkg_metadata_reference table row timestamp column
value is in ISO 8601 UTC format.

*Test Method*:

1. SELECT timestamp from gpkg_metadata_reference.
2. Not testable if returns an empty result set
3. For each row from step 1
    - Fail if format of returned value does not match yyyy-mm-ddThh:mm:ss.hhhZ
    - Log pass otherwise
4. Pass if logged pass and no fails.

*Reference*:    Clause 2.4.3.1.2 Req 58:

*Test Type*:    Capability


**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_md_file_id

*Test Purpose*: Verify that every gpkg_metadata_reference table row md_file_id column
value is an id column value from the gpkg_metadata table.

*Test Method*:

1.   SELECT md_file_id FROM gpkg_metadata_reference
2.   Not testable if returns an empty result set
3.   SELECT gmr.md_file_id, gm.id FROM gpkg_metadata_reference AS gmr
4.   LEFT OUTER JOIN gpkg_metadata gm ON gmr.md_file_id = gm.id
5.   Fail if result set is empty
6.   Fail if any result set gm.id values are NULL
7.   Pass otherwise

*Reference*:     Clause 2.4.3.1.2 Req 59:

*Test Type*:     Capability



**Test Case ID**: /opt/metadata/metadata_reference/data/data_values_md_parent_id

*Test Purpose*: Verify that every gpkg_metadata_reference table row md_parent_id column
 value that is not null is an id column value from the gpkg_metadata_table that is not equal to
 the md_file_id column value for that row.

*Test Method*:

1.    SELECT md_file_id FROM gpkg_metadata_reference
2.    Not testable if returns an empty result set
3.    SELECT gmr.md_file_id, gmr.md_parent_id
4.    FROM gpkg_metadata_reference AS gmr
5.    WHERE gmr.md_file_id == gmr.md_parent_id
6.    Fail if result set is not empty
7.    SELECT gmr.md_file_id, gmr.md_parent_id, gm.id
8.    FROM gpkg_metadata_reference AS gmr
9.    LEFT OUTER JOIN gpkg_metadata gm ON gmr.md_parent_id =gm.id
10.   Fail if any result set gm.id values are NULL
11.   Pass otherwise

*Reference*:     Clause 2.4.3.1.2 Req 60:

*Test Type*:     Capability

==== Extension Mechanism

===== Extensions

====== Data

*Table Definition* 


**Test Case ID**: /opt/extension_mechanism/extensions/data/table_def

*Test Purpose*: Verify that a gpkg_extensions table exists and has the correct definition.

*Test Method*:

1. SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name =
  'gpkg_extensions'
2. Fail if returns an empty result set.
3. Pass if the column names and column definitions in the returned Create TABLE
  statement in the sql column value, including data type, nullability, default values and
  primary, foreign and unique key constraints match all of those in the contents of
  Table 23. Column order, check constraint and trigger definitions, and other column
  definitions in the returned sql are irrelevant.
4. Fail otherwise.

*Reference*:     Clause 2.6.1.1.1 Req 61:

*Test Type*:     Basic

*Table Data Values* 


**Test Case ID**: /opt/extension_metchanism/extensions/data/data_values_table_name

*Test Purpose*: Verify that the table_name column values in the gpkg_extensions table are
 valid.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_extensions
2. Not testable if returns an empty result set
3. For each row from step one
  - Fail if table_name value is NULL and column_name value is not NULL.
  - SELECT DISTINCT ge.table_name AS ge_table, sm.tbl_name
      FROM gpkg_extensions AS ge LEFT OUTER JOIN sqlite_master AS sm ON
      ge.table_name = sm.tbl_name
  - Log pass if every row ge.table_name = sm.tbl_name (MAY both be NULL).
4. Pass if logged pass and no fails.

*Reference*:    Clause 2.6.1.1.2 Req 63:

*Test Type*:    Capability



**Test Case ID**: /opt/extension_metchanism/extensions/data/data_values_column_name

*Test Purpose*: Verify that the column_name column values in the gpkg_extensions table are
 valid.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_extensions
2. Not testable if returns an empty result set
3. SELECT table_name, column_name FROM gpkg_extensions WHERE table_name
  IS NOT NULL AND column_name IS NOT NULL
4. Pass if returns an empty result set
5. For each row from step 3
  - PRAGMA table_info(table_name)
  - Fail if gpkg_extensions.column_name value does not equal a name column value
      returned by PRAGMA table_info.
  - Log pass otherwise
6. Pass if logged pass and no fails.

*Reference*:    Clause 2.6.1.1.2 Req 63:

*Test Type*:    Capability



**Test Case ID**: /opt/extension_mechanism/extensions/data/data_values_extension_name

*Test Purpose*: Verify that the extension_name column values in the gpkg_extensions table
 are valid.

*Test Method*:

1. SELECT extension_name FROM gpkg_extensions
2. Not testable if returns an empty result set
3. For each row returned from step 1
  - Log pass if extension_name is one of those listed in Table 14
  - Separate extension_name into &lt;author&gt; and &lt;extension&gt; at the first "_"
  - Fail if &lt;author&gt; is "gpkg"
  - Fail if &lt;author&gt; contains characters other than [a-zA-Z0-9]
  - Fail if &lt;extension&gt; contains characters other than [a-zA-Z0-9_]
  - Log pass otherwise
4. Pass if logged pass and no fails.

*Reference*:    Clause 2.6.1.1.2 Req 64:

*Test Type*:    Capability


===== API

====== API GeoPackage SQLite Config


**Test Case ID**: /opt/extension_mechanism/extensions/api/api_geopackage_sqlite_config

*Test Purpose*: Verify that a GeoPackage SQLite Extension has the API GeoPackage SQLite
 Configuration compile and run time options.

*Test Method*:

1.   SELECT sqlite_compileoption_used('SQLITE_OMIT_LOAD_EXTENSION')
2.   Fail if returns 1
3.   SELECT sqlite_compileoption_used('SQLITE_OMIT_VIRTUALTABLE')
4.   Fail if returns 1
5.   SELECT sqlite_compileoption_used('SQLITE_ENABLE_RTREE')
6.   Fail if returns 0
7.   SELECT sqlite_compileoption_used('SQLITE_RTREE_INT_ONLY')
8.   Fail if returns 1
9.   Pass otherwise

*Reference*:    Clause 2.6.1.2.1 Req 65:

*Test Type*:    Basic

*Safe GeoPackage SQLite Config* 

**Test Case ID**: /opt/extension_mechanism/extensions/api/safe_geopackage_sqlite_config

*Test Purpose*: Verify that a GeoPackage SQLite Extension has the Safe GeoPackage
 SQLite Configuration compile and run time options.

*Test Method*:

1.   SELECT sqlite_compileoption_used('SQLITE_DEFAULT_FOREIGN_KEYS ')
2.   Fail if returns 0
3.   SELECT sqlite_compileoption_used('SQLITE_OMIT_FOREIGN_KEY')
4.   Fail if returns 1
5.   PRAGMA foreign_keys
6.   Fail if returns 0
7.   SELECT sqlite_compileoption_used('SQLITE_OMIT_INTEGRITY_CHECK')
8.   Fail if returns 1
9.    SELECT sqlite_compileoption_used('SQLITE_OMIT_SUBQUERY')
10.   Fail if returns 1
11.   SELECT sqlite_compileoption_used('SQLITE_OMIT_TRIGGER')
12.   Fail if returns 1
13.   Pass otherwise

*Reference*:     Clause 2.6.1.2.2 Req 66:

*Test Type*:     Basic

=== Registered Extensions



**Test Case ID**: /reg_ext/all/author_name/not_gpkg/not_features_or_tiles

*Test Purpose*: Verify that any table in a GeoPackage file subject to a registered extension
 with an author_name other than "gpkg" is not described by a gpkg_contents table row with a
 data_type value of 'features' or 'tiles'.

*Test Method*:

1. /opt/extension_mechanism/extensions/data/table_def
2. Not testable if failed
3. SELECT table_name FROM geopackage_contents
  WHERE data_type IN ('features','tiles') AND table_name IN
  (SELECT table_name FROM gpkg_extensions WHERE
  substr(lower(extension_name),1,4. != 'gpkg')
4. Fail if result set is not empty
5. Pass otherwise

*Reference*:     Clause 3 Req 67:

*Test Type*:     Basic

==== Features

===== Geometry Encoding

======   Data

*BLOB Format - Extensions Name* 


**Test Case ID**: /reg_ext/features/geometry_encoding/data/ext_name

*Test Purpose*: Verify that an extension name in the form
 &lt;author_name&gt;_geometry_encoding is defined for an author name other than "gpkg" for
 each geometry BLOB format other than GeoPackageBinary used in a GeoPackage file.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type NOT
  IN ('features', 'tiles'))
2. Not testable if returns an empty result set
3. For each row table_name, column_name from step 1
      * SELECT result_set_column_name FROM result_set_table_name
      * Not testable if returns an empty result set
      * For each geometry column value from step a
	      - If the first three bytes of geometry column value are not "GPB", then
		    + /opt/extension_mechanism/extensions/data/table_def
		    + Fail if failed
		    + SELECT extension_name FROM gpkg_extensions WERE
			table_name = result_set_table_name AND column_name =
			result_set_column_name AND
			substr(lower(extension_name),1,4. != 'gpkg')
				* Fail if returns an empty result set
				* Separate extension_name into &lt;author&gt; and
				  &lt;extension&gt; at the first "_"
				* Fail if &lt;extension&gt; is not '_geometry_encoding'.
				* Otherwise log pass
4. Pass if logged pass and no fails

*Reference*:     Clause 3.1.1.1.2 Req 68:

*Test Type*:     Basic

*BLOB Format - Extensions Row* 


**Test Case ID**: /reg_ext/features/geometry_encoding/data/ext_row

*Test Purpose*: Verify that the gpkg_extensions table contains a row with an extension_name
 in the form &lt;author_name&gt;_geometry_encoding is defined for an author name other than
 "gpkg" for each table_name and column_name that contain a geometry BLOB format other
 than GeoPackageBinary in a GeoPackage file.

*Test Method*:

Same as /reg_ext/features/geometry_encoding/data/ext_name

*Reference*:     Clause 3.1.1.1.3 Req 69:

*Test Type*:     Capability


===== Geometry Types

======   Data

*Extension Types* 


**Test Case ID**: /reg_ext/features/geometry_encoding/data/extension_types_existing_sparse_data

*Test Purpose*: Verify that existing extended non-linear geometry types are stored in valid
 GeoPackageBinary format encodings.

*Test Method*:

1. SELECT table_name FROM gpkg_geometry_columns
2. Not testable if returns an empty result set
3. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns
  WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE
  data_type = 'features'),
4. Fail if returns an empty result set
5. For each row from step 3 
      + SELECT cn FROM tn;
      + For each row from step a, if bytes 2-5 of cn.wkb as uint32 in endianness of
	  gc.wkb byte 1of cn from #1 are a geometry type value from Annex G Table
	  46, then
	    - Log cn.header values, wkb endianness and geometry type
	    - If cn.wkb is not correctly encoded per ISO 13249-3 clause 5.1.46 then
		  log fail
	    - If cn.flags.E is 1 - 4 and some cn.wkbx is outside of
		  cn.envelope.minx,maxx then log fail
	    - If cn.flags.E is 1 - 4 and some gc.wkby is outside of
		  cn.envelope.miny,maxy then log fail
	    -    If cn.flags.E is 2,4 and some gc.wkb.z is outside of
		  cnenvelope.minz,maxz then log fail
	    - If cn.flags.E is 3,4 and some gc.wkb.m is outside of
		  cn.envelope.minm,maxm then log fail
	    - If cn.flags.E is 5-7 then log fail
	    - Otherwise log pass
6. Log pass if log contains pass and no fails

*Reference*:     Clause 3.1.2.1.1 Req 70:

*Test Type*:     Capability


**Test Case ID**: /reg_ext/features/geometry_encoding/data/extension_types_all_types_test_data

*Test Purpose*: Verify that all extended non-linear geometry types and options are stored in
 valid GeoPackageBinary format encodings.

*Test Method*:

1. Open GeoPackage that has feature geometry values of geometry type in Annex G, for
  an assortment of srs_ids, for an assortment of coordinate values, without and with z
  and/or m values, in both big and little endian encodings:
2. /reg_ext/features/geometry_encoding/data/extension_types_existing_sparse_data
3. Pass if log contains pass record for big and little endian GPB headers containing big
  and little endian WKBs for 0-1 envelope contents indicator codes for every geometry
  type value from Annex G Table 47 without and with z and/or m values.
4. Fail otherwise

*Reference*:     Clause 3.1.2.1.1 Req 70:

*Test Type*:     Capability

*Geometry Types -- Extensions Name* 


**Test Case ID**: /reg_ext/features/geometry_encoding/data/extension_name

*Test Purpose*: Verify that an extension name in the form gpkg_geom_&lt;gname&gt; is defined
 for each &lt;gname&gt; extension geometry type from Annex G Table 47 used in a GeoPackage
 file.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
    table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
    'features'))
2. Not testable if result set is empty
3. For each row result set table_name, column_name from step 3
	- SELECT result_set_column_name FROM result_set_table_name
	- For each geometry column value from step a
	      + If the first three bytes of each geometry column value are "GPB", then
		      * /opt/extension_mechanism/extensions/data/table_def
		      * Fail if failed
		      * SELECT ST_GeometryType(geometry column value) AS lt;gtype&gt;;
		      * SELECT extension_name FROM gpkg_extensions WERE
			    table_name = result_set_table_name AND column_name =
			    result_set_column_name AND extension_name = 'gpkg_geom_'
			    || &lt;gtype&gt;
				  - Fail if result set is empty
				  - Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.1.2.1.2 Req 71:

*Test Type*:     Basic

*Geometry Types -- Extensions Row* 


**Test Case ID**: /reg_ext/features/geometry_encoding/data/extension_row

*Test Purpose*: Verify that the gpkg_extensions table contains a row with an extension_name
 in the form gpkg_geom_&lt;gname&gt; for each table_name and column_name in the
 gpkg_geometry_columns table with a &lt;gname&gt; geometry_type_name.

*Test Method*:

/reg_ext/features/geometry_encoding/data/extension_name


*Reference*:     Clause 3.1.2.1.3 Req 72:

*Test Type*:     Capability


===== Spatial Indexes

======   Data

*Spatial Indexes Implementation* 


**Test Case ID**: /reg_ext/features/spatial_indexes/implementation

*Test Purpose*: Verify the correct implementation of spatial indexes on feature table
 geometry columns.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
  'features'))
2. Not testable if result set is empty
3. For each row table_name, column_name from step 1
      - SELECT sql FROM sqlite_master WHERE tbl_name = 'rtree_' ||
	  result_set_table_name || '_' || result_set_column_name
      - Not testable if result set is empty
      - Fail if returned sql != 'CREATE VIRTUAL TABLE rtree_' ' ||
	  result_set_table_name || '_' || result_set_column_name || USING rtree(id, minx,
	  maxx, miny, maxy)
      - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tname =
	  'rtree_' || result_set_table_name || '_' || result_set_column_name || '_insert'
      - Fail if returned sql != result of populating insert triggers template in Table 39
	  using result_set_table_name for &lt;t&gt; and result_set_column_name for &lt;c&gt;
      - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND name LIKE
	  'rtree_' || result_set_table_name || '_' || result_set_column_name || '_update%'
      - Fail if returned sql != result of populating 4 update triggers templates in Table
	  39 using result_set_table_name for &lt;t&gt; and result_set_column_name for &lt;c&gt;
      - SELECT sql FROM sqlite_master WHERE type='trigger' AND name =
	  'rtree_' || result_set_table_name || '_' || result_set_column_name || '_delete'
      - Fail if returned sql != result of populating delete trigger template in Table 39
	  using result_set_table_name for &lt;t&gt; and result_set_column_name for &lt;c&gt;
      - Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.1.3.1.1 Req 73:

*Test Type*:     Capability
 
*Spatial Indexes - Extensions Name* 


**Test Case ID**: /reg_ext/features/spatial_indexes/extension_name

*Test Purpose*: Verify that the "gpkg_rtree_index" extension name is used to register spatial
 index extensions.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
  'features'))
2. Not testable if result set is empty
3. For each row table_name, column_name from step 3
      - SELECT sql FROM sqlite_master WHERE tbl_name = 'rtree_' ||
	  result_set_table_name || '_' || result_set_column_name
      - Not testable if returns an empty result set
      - /opt/extension_mechanism/extensions/data/table_def
      - Fail if failed
      - SELECT extension_name from gpkg_extensions WHERE table_name =
	  result_set_table_name AND column_name = result_set_column_name
      - Log pass if result is "gpkg_rtree_index"
      - Fail otherwise

4. Pass if logged pass and no fails

*Reference*:     Clause 3.1.3.1.2 Req 74:

*Test Type*:     Basic

*Spatial Indexes - Extensions Row* 


**Test Case ID**: /reg_ext/features/spatial_indexes/extension_row

*Test Purpose*: Verify that spatial index extensions are registered using the
 "gpkg_rtree_index" name in the gpkg_extensions table.

*Test Method*:

/reg_ext/features/spatial_indexes/extension_name


*Reference*:     Clause 3.1.3.1.3 Req 75:

*Test Type*:     Capability
 
===== Geometry Type Triggers

====== Data

*Geometry Type Triggers Implementation* 


**Test Case ID**: /reg_ext/features/geometry_type_triggers/implementation

*Test Purpose*: Verify that user feature data table geometry type triggers are implemented
 correctly.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
  'features'))
2. Not testable if returns an empty result set
3. For each row table_name, column_name from step 1
      - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tbl_name =
	  'fgti_' || result_set_table_name || '_' || result_set_column_name
      - Not testable if returns an empty result set
      - Fail if sql != result of populating the first trigger template in Table 17 with &lt;t&gt;
	  as result_set_table_name and &lt;c&gt; as result_set_column_name
      - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tbl_name =
	  'fgtu_' || result_set_table_name || '_' || result_set_column_name
      - Fail if sql != result of populating the second trigger template in Table 17 with
	  &lt;t&gt; as result_set_table_name and &lt;c&gt; as result_set_column_name
      - Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.1.4.1.1 Req 76:

*Test Type*:     Capability

*Geometry Type Triggers - Extensions Name* 


**Test Case ID**: /reg_ext/features/geometry_type_triggers/extension_name

*Test Purpose*: Verify that the "gpkg_geometry_type_trigger" extension name is used to
 register geometry type triggers.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
  'features'))
2. Not testable if result set is empty
3. For each row table_name, column_name from step 1
  - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tbl_name =
      'fgti_' || result_set_table_name || '_' || result_set_column_name
  - Not testable if result set is empty
  - /opt/extension_mechanism/extensions/data/table_def
  - Fail if failed
  - SELECT extension_name from gpkg_extensions WHERE table_name =
      result_set_table_name AND column_name = result_set_column_name
  - Log pass if result is "gpkg_geometry_type_trigger"
  - Fail otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.1.4.1.2 Req 77:

*Test Type*:     Basic

*Geometry Type Triggers - Extensions Row* 


**Test Case ID**: /reg_ext/features/geometry_type_triggers/extension_row

*Test Purpose*: Verify that geometry type triggers are registered using the
 "gpkg_geometry_type_trigger" extension name.

*Test Method*:

/reg_ext/features/geometry_type_triggers/extension_name


*Reference*:     Clause 3.1.4.1.3 Req 78:

*Test Type*:     Capability

===== SRS_ID Triggers

======   Data

*SRS_ID Triggers - Implementation*


**Test Case ID**: /reg_ext/features/srs_id_triggers/implementation

*Test Purpose*: Verify that user feature data table srs_id triggers are implemented correctly.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
  'features'))
2. Not testable if result set is empty
3. For each row table_name, column_name from step 1
      - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tbl_name =
	  'fgsi_' || result_set_table_name || '_' || result_set_column_name
      - Not testable if result set is empty
      - Fail if sql != result of populating the first trigger template in Table 18 with &lt;t&gt;
	  as result_set_table_name and &lt;c&gt; as result_set_column_name
      - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tbl_name =
	  'fgsu_' || result_set_table_name || '_' || result_set_column_name
      - Fail if sql != result of populating the second trigger template in Table 18 with
	  &lt;t&gt; as result_set_table_name and &lt;c&gt; as result_set_column_name
      - Log pass otherwise
4. Pass if logged pass and no fails



*Reference*:     Clause 3.1.5.1.1 Req 79:

*Test Type*:     Capability

*SRS_ID Triggers - Extensions Name*


**Test Case ID**: /reg_ext/features/srs_id_triggers/extension_name

*Test Purpose*: Verify that the "gpkg_srs_id_trigger" extension name is used to register
 srs_id triggers.

*Test Method*:

1. SELECT table_name, column_name FROM gpkg_geometry_columns WHERE
  table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type ==
  'features'))
2. Not testable if result set is empty
3. For each row table_name, column_name from step 1
  - SELECT sql FROM sqlite_master WHERE type = 'trigger' AND tbl_name =
      'fgsi_' || result_set_table_name || '_' || result_set_column_name
  - Not testable if result set is empty
  - /opt/extension_mechanism/extensions/data/table_def
  - Fail if failed
  - SELECT extension_name from gpkg_extensions WHERE table_name =
      result_set_table_name AND column_name = result_set_column_name
  - Pass if result is "gpkg_srs_id_trigger"
  - Fail otherwise

*Reference*:     Clause 3.1.5.1.2 Req 80:

*Test Type*:     Basic

*SRS_ID Triggers - Extensions Row*

**Test Case ID**: /reg_ext/features/srs_id_triggers/extension_row

*Test Purpose*: Verify that srs_id triggers are registered using the "gpkg_srs_id_trigger"
 extension name.

*Test Method*:

/reg_ext/features/srs_id_triggers/extension_name


*Reference*:     Clause 3.1.5.1.3 Req 81:

*Test Type*:     Capability

====   Tiles

===== Zoom Levels

====== Data

*Zoom Other IntervalsExtensions Name* 


**Test Case ID**: /reg_ext/tiles/zoom_levels/data/zoom_other_ext_name

*Test Purpose*: Verify that the "gpkg_zoom_other" extension name is used to register tiles
 tables with other than factors of two zoom intervals.

*Test Method*:

1. SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles'
2. Not testable if empty result set
3. For each row table_name from step 1
      - SELECT zoom_level, pixel_x_size, pixel_y_size FROM tile_matrix_metadata
	  WHERE table_name = selected table name ORDER BY zoom_level ASC
      - Not testable if returns empty result set
      - Not testable if there are not two rows with adjacent zoom levels
      - Not testable if no pair of rows for adjacent zoom levels have pixel_x_size or
	  pixel_y_size values that differ by other than factors of two
      - /opt/extension_mechanism/extensions/data/table_def
      - Fail if failed
      - SELECT * FROM gpkg_extensions WHERE table_name = selected table
	  name AND extension_name = 'gpkg_zoom_other'
      - Fail if returns an empty result set
      - Log pass otherwise
4. Pass if logged pass and no fails



*Reference*:     Clause 3.2.1.1.2 Req 82:

*Test Type*:     Basic

*Zoom Other Intervals - Extensions Row* 


**Test Case ID**: / reg_ext/tiles/zoom_levels/data/zoom_other_ext_row

*Test Purpose*: Verify that tiles tables with other than factors of two zoom intervals are
 registered using the "gpkg_zoom_other" extension name.

*Test Method*:

/reg_ext/tiles/zoom_levels/data/zoom_other_ext_name


*Reference*:     Clause 3.2.1.1.3 Req 83:

*Test Type*:     Capabilty

===== Tile Encoding WEBP

======    Data

*WEBP - Extensions Name* 


**Test Case ID**: /reg_ext/tiles/tile_encoding_webp/data/webp_ext_name

*Test Purpose*: Verify that the "gpkg_webp" extensions name is used to register WEBP tile
 encoding implementations.

*Test Method*:

1. SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles'
2. Not testable if empty result set
3. For each row table_name from step 1
      - Select tile_data FROM row table_name
      - For each row tile_data from step a
	      + Log webp if tile data in MIME type image/webp
      - Not testable if no logged webps
      - /opt/extension_mechanism/extensions/data/table_def
      - Fail if failed
      - SELECT * FROM gpkg_extensions WHERE table_name = selected table
	  name AND extension_name = 'gpkg_webp'
      - Fail if returns an empty result set
      - Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.2.2.2.1 Req 84:

*Test Type*:     Basic

====== WEBP - Extensions Row


**Test Case ID**: /reg_ext/tiles/tile_encoding_webp/data/webp_ext_row

*Test Purpose*: Verify that WEBP tile encodings are registered using the "gpkg_webp"
 extensions name.

*Test Method*:

/reg_ext/tiles/tile_encoding_webp/data/webp_ext_name


*Reference*:     Clause 3.2.2.2.2 Req 85:

*Test Type*:     Capability

===== Tile Encoding TIFF

====== Data

*TIFF - Extensions Name* 


**Test Case ID**: /reg_ext/tiles/tile_encoding_tiff/data/tiff_ext_name

*Test Purpose*: Verify that the "gpkg_tiff" extensions name is used to register TIFF tile
 encoding implementations.

*Test Method*:

1. SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles'
2. Not testable if empty result set
3. For each row table_name from step 3
      - Select tile_data FROM row table_name
      - For each row tile_data from step a
	      + Log tiff if tile data in MIME type image/tiff
      - Not testable if no logged webps
      - /opt/extension_mechanism/extensions/data/table_def
      - Fail if failed
      - SELECT * FROM gpkg_extensions WHERE table_name = selected table
	  name AND extension_name = 'gpkg_tiff'
      - Fail if returns an empty result set
      - Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.2.3.1.2 Req 86:

*Test Type*:     Basic

*TIFF - Extensions Row* 


**Test Case ID**: /reg_ext/tiles/tile_encoding_tiff/data/tiff_ext_row

*Test Purpose*: Verify that TIFF tile encodings are registered using the "gpkg_tiff"
 extensions name.

*Test Method*:

/reg_ext/tiles/tile_encoding_tiff/data/tiff_ext_name


*Reference*:     Clause 3.2.3.1.3 Req 87:

*Test Type*:     Capability

===== Tile Encoding NITF

====== Data

*NITF - Extensions Name* 


**Test Case ID**: /reg_ext/tiles/tile_encoding_nitf/data/nitf_ext_name

*Test Purpose*: Verify that the "gpkg_nitf" extensions name is used to register NITF tile
 encoding implementations.

*Test Method*:

1. SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles'
2. Not testable if empty result set
3. For each row table_name from step 3
      - Select tile_data FROM row table_name
      - For each row tile_data from step a
	      + Log nitf if tile data in MIME type application/vnd.NITF
      - Not testable if no logged webps
      - /opt/extension_mechanism/extensions/data/table_def
      - Fail if failed
      - SELECT * FROM gpkg_extensions WHERE table_name = selected table
	  name AND extension_name = 'gpkg_nitf'
      - Fail if returns an empty result set
      - Log pass otherwise
4. Pass if logged pass and no fails

*Reference*:     Clause 3.2.4.1.2 Req 88:

*Test Type*:     Basic

*NITF - Extensions Row* 


**Test Case ID**: /reg_ext/tiles/tile_encoding/nitf/data/nitf_ext_row

*Test Purpose*: Verify that NITF tile encodings are registered in the gpkg_extensions table
 using the "gpkg_nitf" extensions name.

*Test Method*:

/reg_ext/tiles/tile_encoding_nitf/data/nitf_ext_name


*Reference*:     Clause 3.2.4.1.3 Req 89:

*Test Type*:     Capability

===== Tile Encoding Other

====== Data

*Other Mime Type - Extensions Name* 


**Test Case ID**: /reg_ext/tiles/tile_encoding/other/data/other_ext_name

*Test Purpose*: Verify that an extension name in the form
 &lt;author_name&gt;_&lt;other&gt;_mime_type is defined for an author name other than "gpkg" for
 each other MIME image format used for tile_data columns in tile matrix set user data tables,
 where &lt;other&gt; is replaced by the other MIME type abbreviation in uppercase.

*Test Method*:

1. SELECT table_name FROM geopackage_contents WHERE data_type = 'tiles'
2. Not testable if empty result set
3. For each row table_name from step 3
      + Select tile_data FROM row table_name
      + For each row tile_data from step a
		- Log other MIME type name if tile data not in MIME type png, jpeg, webp, tiff or nitf
      + Not testable if no logged others
      + /opt/extension_mechanism/extensions/data/table_def
      + Fail if failed
      + For each other logged MIME type name for this table_name
		- SELECT extension_name FROM gpkg_extensions WHERE
		    table_name = result set table name AND column_name = 'tile_data'
		    AND substr(lower(extension_name),1,4. !- 'gpkg') AND
		    instr(extension_name, logged MIME type name) != 0
		- Fail if returns an empty result set
	        - Separate extension_name into &lt;author&gt; and &lt;extension&gt; at the first "_"
	        - Separate &lt;extension&gt; into &lt;mime&gt; and &lt;ext&gt; at the first "_"
		- Fail if &lt;mime&gt; not logged MIME type
	        - Fail if &lt;ext&gt; not "mime_type"
	        - Log pass otherwise
4. Pass if logged pass and no fails"

*Reference*:     Clause 3.2.5.1.2 Req 90:

*Test Type*:     Basic

*Other Mime Type - Extensions Row* 


**Test Case ID**: /reg_ext/tiles_tile_encoding/other/data/other_ext_row

*Test Purpose*: Verify that other mime image type tile encodings are registered in the
 gpkg_extensions table using names of the form &lt;author_name&gt;_&lt;other&gt;_mime_type.

*Test Method*:

/reg_ext/tiles/tile_encoding/other/data/other_ext_name


*Reference*:    Clause 3.2.5.1.3 Req 91:

*Test Type*:    Capability

==== Any Tables

===== Other Trigger

====== Data

*Other Trigger - Extensions Name* 


**Test Case ID**: /reg_ext/any/other_triggers/data/ext_name

*Test Purpose*: Verify that an extension name in the form &lt;author_name&gt;_&lt;extension&gt; is
 defined for an author name other than "gpkg" for each other trigger implementation that
 uses SQL functions other than those provided by SQLite or the GeoPackage Minimal
 Runtime SQL Functions.

*Test Method*:

1. SELECT sql, tbl_name FROM sqlite_master WHERE type='trigger'
2. For each row sql, tbl_name from step 1
      - If sql contains an SQL function other than those provided by SQLite or the
	  GeoPackage Minimal Runtime SQL Functions
		+ Log trigger
	        + /opt/extension_mechanism/extensions/data/table_def
	        + Fail if failed
	        + SELECT extension_name FROM gpkg_extensions WHERE
		  table_name = tbl_name AND substr(lower(extension_name),1,4. !-
		  'gpkg')
	        + Fail if returns an empty result set
	        + Log pass otherwise
3. Not testable if no logged triggers
4. Pass if logged pass and no fails

*Reference*:    Clause 3.3.1.1.2 Req 92:

*Test Type*:    Basic

*Other Trigger - Extensions Row* 

**Test Case ID**: /reg_ext/any/other_triggers/data/ext_row

*Test Purpose*: Verify that other trigger implementations that use SQL functions other than
 those provided by SQLite or the GeoPackage Minimal Runtime SQL Functions.are
 registered with &lt;author_name&gt;_&lt;extension&gt; names in the gpkg_extensions table.

*Test Method*:

/reg_ext/any/other_triggers/data/ext_name


*Reference*:    Clause 3.3.1.1.3 Req 93:

*Test Type*:   Capability
